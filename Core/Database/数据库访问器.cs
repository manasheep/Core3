// ===============================================================================
// Microsoft Data Access Application Block for .NET 3.0
//
// AdoHelper.cs
//
// This file contains an abstract implementations of the AdoHelper class.
//
// For more information see the Documentation. 
// ===============================================================================
// Release history
// VERSION	DESCRIPTION
//   2.0	Added support for 填充数据集, 更新数据集 and "Param" helper methods
//   3.0	New abstract class supporting the same methods using ADO.NET interfaces
//
// ===============================================================================
// Copyright (C) 2000-2001 Microsoft Corporation
// All rights reserved.
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY
// OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT
// LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR
// FITNESS FOR A PARTICULAR PURPOSE.
// ==============================================================================

using System;
using System.Collections;
using System.Configuration;
using System.Data;
using System.Data.Common;
using System.Reflection;
using System.Xml;
using System.Diagnostics;

namespace Core.Database
{
	/// <summary>
	/// The AdoHelper class is intended to encapsulate high performance, scalable best practices for 
	/// common data access uses.   It uses the Abstract Factory pattern to be easily extensible
	/// to any ADO.NET provider.  The current implementation provides helpers for SQL Server, ODBC,
	/// OLEDB, and Oracle.
	/// </summary>
	public abstract class 数据库访问器
	{
		/// <summary>
		/// This enum is used to indicate whether the 连接 was provided by the caller, or created by AdoHelper, so that
		/// we can set the appropriate CommandBehavior when calling 获得读取器()
		/// </summary>
		protected enum 连接权限	
		{
			/// <summary>Connection is owned and managed by ADOHelper</summary>
			内部, 
			/// <summary>Connection is owned and managed by the caller</summary>
			外部
		}

		#region 成员声明
		// necessary for handling the general case of needing event handlers for 更新行/ed events
		/// <summary>
		/// Internal handler used for bubbling up the event to the user
		/// </summary>
		protected 更新行处理器 m_rowUpdating;
		/// <summary>
		/// Internal handler used for bubbling up the event to the user
		/// </summary>
		protected 更新行完毕处理器 m_rowUpdated;
		#endregion

		#region 抽象方法定义
		/// <summary>
		/// Returns an IDbConnection object for the given 连接 string
		/// </summary>
        /// <param name="连接字符串">The 连接 string to be used to create the 连接</param>
		/// <returns>An IDbConnection object</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接字符串 is null</exception>
		public abstract IDbConnection 获取连接( string 连接字符串 );

		/// <summary>
		/// Returns an IDbDataAdapter object
		/// </summary>
		/// <returns>The IDbDataAdapter</returns>
		public abstract IDbDataAdapter 获取数据适配器();

		/// <summary>
		/// Calls the CommandBuilder.DeriveParameters method for the specified provider, doing any setup and cleanup necessary
		/// </summary>
        /// <param name="命令">The IDbCommand referencing the stored procedure from which the parameter information is to be derived. The derived parameters are added to the Parameters collection of the IDbCommand. </param>
		public abstract void 获得参数( IDbCommand 命令 );

		/// <summary>
		/// Returns an IDataParameter object
		/// </summary>
		/// <returns>The IDataParameter object</returns>
		public abstract IDataParameter 获取参数();
		
		/// <summary>
		/// Execute an IDbCommand (that returns a resultset) against the provided IDbConnection. 
		/// </summary>
		/// <example>
		/// <code>
		/// XmlReader r = helper.获得XML读取器(命令);
		/// </code></example>
        /// <param name="命令">The IDbCommand to execute</param>
		/// <returns>An XmlReader containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令 is null.</exception>
		public abstract XmlReader 获得XML读取器( IDbCommand 命令 );

		/// <summary>
		/// Provider specific code to set up the updating/ed event handlers used by 更新数据集
		/// </summary>
        /// <param name="数据适配器">DataAdapter to attach the event handlers to</param>
        /// <param name="更新行处理器">The handler to be called when a row is updating</param>
        /// <param name="更新行完毕处理器">The handler to be called when a row is updated</param>
		protected abstract void 添加更新事件处理器(IDbDataAdapter 数据适配器, 更新行处理器 更新行处理器, 更新行完毕处理器 更新行完毕处理器);

		/// <summary>
		/// Returns an array of IDataParameters of the specified 大小
		/// </summary>
		/// <param name="大小">大小 of the array</param>
		/// <returns>The array of IDataParameters</returns>
        protected abstract IDataParameter[] 获得数据参数(int 大小);

		/// <summary>
		/// Handle any provider-specific issues with BLOBs here by "washing" the IDataParameter and returning a new one that is set up appropriately for the provider.
		/// </summary>
        /// <param name="连接">The IDbConnection to use in cleansing the parameter</param>
        /// <param name="参数">The parameter before cleansing</param>
		/// <returns>The parameter after it's been cleansed.</returns>
		protected abstract IDataParameter 获取冒泡参数(IDbConnection 连接, IDataParameter 参数);
		#endregion

		#region 代理
		// also used in our general case of 更新行/ed events
		/// <summary>
		/// Delegate for creating a RowUpdatingEvent handler
		/// </summary>
		/// <param name="obj">The object that published the event</param>
		/// <param name="e">The RowUpdatingEventArgs for the event</param>
		public delegate void 更新行处理器(object obj, RowUpdatingEventArgs e);
		/// <summary>
		/// Delegate for creating a RowUpdatedEvent handler
		/// </summary>
		/// <param name="obj">The object that published the event</param>
		/// <param name="e">The RowUpdatedEventArgs for the event</param>
		public delegate void 更新行完毕处理器(object obj, RowUpdatedEventArgs e);
		#endregion

		#region 工厂
		/// <summary>
		/// Create an AdoHelper for working with a specific provider (i.e. Sql, Odbc, OleDb, Oracle)
		/// </summary>
        /// <param name="供应者程序集">继承自数据库访问器的子类所在的程序集名称</param>
        /// <param name="供应者类型">继承自数据库访问器的子类名称</param>
		/// <returns>An AdoHelper instance of the specified type</returns>
		/// <example><code>
		/// AdoHelper helper = AdoHelper.CreateHelper("GotDotNet.ApplicationBlocks.Data", "GotDotNet.ApplicationBlocks.Data.OleDb");
		/// </code></example>
		public static 数据库访问器 创建访问器( string 供应者程序集, string 供应者类型 )
		{
			Assembly assembly = Assembly.Load( 供应者程序集 );
			object provider = assembly.CreateInstance( 供应者类型 );
			if( provider is 数据库访问器 )
			{
				return provider as 数据库访问器;
			}
			else
			{
				throw new InvalidOperationException( "供应者并未继承数据库访问器类型" );
			}
		}


		/// <summary>
		/// Create an AdoHelper instance for working with a specific provider by using a providerAlias specified in the App.Config file.
		/// </summary>
        /// <param name="供应者别名">The alias to look up</param>
		/// <returns>An AdoHelper instance of the specified type</returns>
		/// <example><code>
		/// AdoHelper helper = AdoHelper.CreateHelper("OracleHelper");
		/// </code></example>
		public static 数据库访问器 创建访问器( string 供应者别名 )
		{
			IDictionary dict;
            try
            {
                dict = System.Configuration.ConfigurationManager.GetSection("DataProviders") as IDictionary;
            }
            catch (Exception e)
            {
                //throw new InvalidOperationException("If the section is not defined on the configuration file this method can't be used to create an AdoHelper instance.", e);
                throw e;
            }

			供应者别名 providerConfig = dict[ 供应者别名 ] as 供应者别名;
			string providerAssembly = providerConfig.程序集名称;
			string providerType = providerConfig.类型名称;

			Assembly assembly = Assembly.Load( providerAssembly );
			object provider = assembly.CreateInstance( providerType );
			if( provider is 数据库访问器 )
			{
				return provider as 数据库访问器;
			}
			else
			{
				throw new InvalidOperationException( "The provider specified does not extends the AdoHelper abstract class." );
			}
		}

		#endregion

		#region 获取参数
		/// <summary>
		/// Get an IDataParameter for use in a SQL 命令
		/// </summary>
        /// <param name="名称">The name of the parameter to create</param>
        /// <param name="值">The 值 of the specified parameter</param>
		/// <returns>An IDataParameter object</returns>
		public virtual IDataParameter 获取参数( string 名称, object 值 )
		{
			IDataParameter parameter = 获取参数();
			parameter.ParameterName = 名称;
			parameter.Value = 值;

			return parameter;
		}

		/// <summary>
		/// Get an IDataParameter for use in a SQL 命令
		/// </summary>
        /// <param name="名称">The name of the parameter to create</param>
        /// <param name="数据类型">The System.Data.DbType of the parameter</param>
        /// <param name="大小">The 大小 of the parameter</param>
        /// <param name="取向">The System.Data.ParameterDirection of the parameter</param>
		/// <returns>An IDataParameter object</returns>
		public virtual IDataParameter 获取参数 ( string 名称, DbType 数据类型, int 大小, ParameterDirection 取向 )
		{
			IDataParameter dataParameter = 获取参数();
			dataParameter.DbType = 数据类型;
			dataParameter.Direction = 取向;
			dataParameter.ParameterName = 名称;

			if (大小 > 0 && dataParameter is IDbDataParameter) 
			{
				IDbDataParameter dbDataParameter = (IDbDataParameter)dataParameter;
				dbDataParameter.Size = 大小;
			}
			return dataParameter;
		}
		
		/// <summary>
		/// Get an IDataParameter for use in a SQL 命令
		/// </summary>
        /// <param name="名称">The name of the parameter to create</param>
        /// <param name="数据类型">The System.Data.DbType of the parameter</param>
        /// <param name="大小">The 大小 of the parameter</param>
        /// <param name="源列">The source column of the parameter</param>
        /// <param name="源版本">The System.Data.DataRowVersion of the parameter</param>
		/// <returns>An IDataParameter object</returns>
		public virtual IDataParameter 获取参数 ( string 名称, DbType 数据类型, int 大小, string 源列, DataRowVersion 源版本 )
		{
			IDataParameter dataParameter = 获取参数();
			dataParameter.DbType = 数据类型;
			dataParameter.ParameterName = 名称;
			dataParameter.SourceColumn = 源列;
			dataParameter.SourceVersion = 源版本;

			if (大小 > 0 && dataParameter is IDbDataParameter) 
			{
				IDbDataParameter dbDataParameter = (IDbDataParameter)dataParameter;
				dbDataParameter.Size = 大小;
			}
			return dataParameter;
		}
		#endregion

		#region 私有功能方法
		/// <summary>
		/// This method is used to attach array of IDataParameters to an IDbCommand.
		/// 
		/// This method will assign a 值 of DbNull to any parameter with a direction of
		/// InputOutput and a 值 of null.  
		/// 
		/// This behavior will prevent default values from being used, but
		/// this will be the less common case than an intended pure output parameter (derived as InputOutput)
		/// where the user provided no input 值.
		/// </summary>
		/// <param name="命令">The 命令 to which the parameters will be added</param>
		/// <param name="命令参数集合">An array of IDataParameterParameters to be added to 命令</param>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令 is null.</exception>
		protected virtual void 附加参数(IDbCommand 命令, IDataParameter[] 命令参数集合)
		{
			if( 命令 == null ) throw new ArgumentNullException( "命令" );
			if( 命令参数集合 != null )
			{
				foreach (IDataParameter p in 命令参数集合)
				{
					if( p != null )
					{
						// Check for derived output 值 with no 值 assigned
						if ( ( p.Direction == ParameterDirection.InputOutput || 
							p.Direction == ParameterDirection.Input ) && 
							(p.Value == null))
						{
							p.Value = DBNull.Value;
						}
						if (p.DbType == DbType.Binary) 
						{
							// special handling for BLOBs
							命令.Parameters.Add(获取冒泡参数(命令.Connection, p));
						}
						else
						{
							命令.Parameters.Add(p);
						}
					}
				}
			}
		}

		/// <summary>
		/// This method assigns 数据行 column values to an IDataParameterCollection
		/// </summary>
		/// <param name="命令参数集合">The IDataParameterCollection to be assigned values</param>
		/// <param name="数据行">The 数据行 used to hold the stored procedure's parameter values</param>
		/// <exception cref="System.InvalidOperationException">Thrown if any of the parameter names are invalid.</exception>
		protected internal void 分配参数值集合(IDataParameterCollection 命令参数集合, DataRow 数据行)
		{
			if (命令参数集合 == null || 数据行 == null)
			{
				// Do nothing if we get no data
				return;
			}

			DataColumnCollection columns = 数据行.Table.Columns;

			int i = 0;
			// Set the parameters values
			foreach(IDataParameter commandParameter in 命令参数集合)
			{
				// Check the parameter name
				if( commandParameter.ParameterName == null || 
					commandParameter.ParameterName.Length <= 1 )
					throw new InvalidOperationException( string.Format( 
						"Please provide a valid parameter name on the parameter #{0}, the ParameterName property has the following value: '{1}'.", 
						i, commandParameter.ParameterName ) );

				if (columns.Contains( commandParameter.ParameterName ) )
					commandParameter.Value = 数据行[commandParameter.ParameterName];
				else if(columns.Contains( commandParameter.ParameterName.Substring(1) ) )
					commandParameter.Value = 数据行[commandParameter.ParameterName.Substring(1)];
	
				i++;
			}
		}

		/// <summary>
		/// This method assigns 数据行 column values to an array of IDataParameters
		/// </summary>
		/// <param name="命令参数集合">Array of IDataParameters to be assigned values</param>
		/// <param name="数据行">The 数据行 used to hold the stored procedure's parameter values</param>
		/// <exception cref="System.InvalidOperationException">Thrown if any of the parameter names are invalid.</exception>
		protected void 分配参数值集合(IDataParameter[] 命令参数集合, DataRow 数据行)
		{
			if ((命令参数集合 == null) || (数据行 == null)) 
			{
				// Do nothing if we get no data
				return;
			}

			DataColumnCollection columns = 数据行.Table.Columns;

			int i = 0;
			// Set the parameters values
			foreach(IDataParameter commandParameter in 命令参数集合)
			{
				// Check the parameter name
				if( commandParameter.ParameterName == null || 
					commandParameter.ParameterName.Length <= 1 )
					throw new InvalidOperationException( string.Format( 
						"Please provide a valid parameter name on the parameter #{0}, the ParameterName property has the following value: '{1}'.", 
						i, commandParameter.ParameterName ) );

				if (columns.Contains( commandParameter.ParameterName ) )
					commandParameter.Value = 数据行[commandParameter.ParameterName];
				else if(columns.Contains( commandParameter.ParameterName.Substring(1) ) )
					commandParameter.Value = 数据行[commandParameter.ParameterName.Substring(1)];
	
				i++;
			}
		}

		/// <summary>
		/// This method assigns an array of values to an array of IDataParameters
		/// </summary>
		/// <param name="命令参数集合">Array of IDataParameters to be assigned values</param>
		/// <param name="参数值集合">Array of objects holding the values to be assigned</param>
		/// <exception cref="System.ArgumentException">Thrown if an incorrect number of parameters are passed.</exception>
		protected void 分配参数值集合(IDataParameter[] 命令参数集合, object[] 参数值集合)
		{
			if ((命令参数集合 == null) || (参数值集合 == null)) 
			{
				// Do nothing if we get no data
				return;
			}

			// We must have the same number of values as we pave parameters to put them in
			if (命令参数集合.Length != 参数值集合.Length)
			{
				throw new ArgumentException("Parameter count does not match Parameter Value count.");
			}

			// Iterate through the IDataParameters, assigning the values from the corresponding position in the 
			// 值 array
			for (int i = 0, j = 命令参数集合.Length, k = 0; i < j; i++)
			{
				if (命令参数集合[i].Direction != ParameterDirection.ReturnValue)
				{
					// If the current array 值 derives from IDataParameter, then assign its Value property
					if (参数值集合[k] is IDataParameter)
					{
						IDataParameter paramInstance;
						paramInstance = (IDataParameter)参数值集合[k];
						if (paramInstance.Direction == ParameterDirection.ReturnValue)
						{
							paramInstance = (IDataParameter)参数值集合[++k];
						}
						if( paramInstance.Value == null )
						{
							命令参数集合[i].Value = DBNull.Value; 
						}
						else
						{
							命令参数集合[i].Value = paramInstance.Value;
						}
					}
					else if (参数值集合[k] == null)
					{
						命令参数集合[i].Value = DBNull.Value;
					}
					else
					{
						命令参数集合[i].Value = 参数值集合[k];
					}
					k++;
				}
			}
		}

		/// <summary>
		/// This method cleans up the parameter syntax for the provider
		/// </summary>
        /// <param name="命令">The IDbCommand containing the parameters to clean up.</param>
		public virtual void 清除参数规则(IDbCommand 命令)
		{
			// do nothing by default
		}

		/// <summary>
		/// This method opens (if necessary) and assigns a 连接, 事务, 命令 type and parameters 
		/// to the provided 命令
		/// </summary>
		/// <param name="命令">The IDbCommand to be prepared</param>
		/// <param name="连接">A valid IDbConnection, on which to execute this 命令</param>
		/// <param name="事务">A valid IDbTransaction, or 'null'</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <param name="命令参数集合">An array of IDataParameters to be associated with the 命令 or 'null' if no parameters are required</param>
		/// <param name="需要关闭连接"><c>true</c> if the 连接 was opened by the method, otherwose is false.</param>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令 is null.</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null.</exception>
		protected virtual void 准备命令(IDbCommand 命令, IDbConnection 连接, IDbTransaction 事务, CommandType 命令类型, string 命令内容, IDataParameter[] 命令参数集合, out bool 需要关闭连接 )
		{
			if( 命令 == null ) throw new ArgumentNullException( "命令" );
			if( 命令内容 == null || 命令内容.Length == 0 ) throw new ArgumentNullException( "命令内容" );

			// If the provided 连接 is not open, we will open it
			if (连接.State != ConnectionState.Open)
			{
				需要关闭连接 = true;
				连接.Open();
			}
			else
			{
				需要关闭连接 = false;
			}

			// Associate the 连接 with the 命令
			命令.Connection = 连接;

			// Set the 命令 text (stored procedure name or SQL statement)
			命令.CommandText = 命令内容;

			// If we were provided a 事务, assign it
			if (事务 != null)
			{
				if( 事务.Connection == null ) throw new ArgumentException( "The 事务 was rolled back or commited, please provide an open 事务.", "事务" );
				命令.Transaction = 事务;
			}

			// Set the 命令 type
			命令.CommandType = 命令类型;

			// Attach the 命令 parameters if they are provided
			if (命令参数集合 != null)
			{
				附加参数(命令, 命令参数集合);
			}
			return;
		}

		/// <summary>
		/// This method clears (if necessary) the 连接, 事务, 命令 type and parameters 
		/// from the provided 命令
		/// </summary>
		/// <remarks>
		/// Not implemented here because the behavior of this method differs on each data provider. 
		/// </remarks>
		/// <param name="命令">The IDbCommand to be cleared</param>
        protected virtual void 清除命令(IDbCommand 命令)
		{
			// do nothing by default
		}

		#endregion private utility methods

		#region 获得数据集

		/// <summary>
		/// Execute an IDbCommand (that returns a resultset) against the database specified in 
		/// the 连接 string. 
		/// </summary>
        /// <param name="命令">The IDbCommand object to use</param>
		/// <returns>A DataSet containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令 is null.</exception>
		public virtual DataSet 获得数据集(IDbCommand 命令)
		{
			bool mustCloseConnection = false;

			// Clean Up Parameter Syntax
			清除参数规则(命令);

			if (命令.Connection.State != ConnectionState.Open)
			{
				命令.Connection.Open();
				mustCloseConnection = true;
			}

			// Create the DataAdapter & DataSet
			IDbDataAdapter da = null;
			try
			{
				da = 获取数据适配器();
				da.SelectCommand = 命令;

				DataSet ds = new DataSet();

				try
				{

					// Fill the DataSet using default values for DataTable names, etc
					da.Fill(ds);
				}
				catch (Exception ex)
				{
					// Don't just throw ex.  It changes the call stack.  But we want the ex around for debugging, so...
					Debug.WriteLine(ex);
					throw;
				}
				
				// Detach the IDataParameters from the 命令 object, so they can be used again
				// Don't do this...screws up output params -- cjb 
				//命令.Parameters.Clear();

				// Return the DataSet
				return ds;
			}
			finally
			{
				if (mustCloseConnection)
				{
					命令.Connection.Close();
				}
				if( da != null )
				{
					IDisposable id = da as IDisposable;
					if( id != null )
						id.Dispose();
				}
			}
		}
		/// <summary>
		/// Execute an IDbCommand (that returns a resultset and takes no parameters) against the database specified in 
		/// the 连接 string. 
		/// </summary>
		/// <example>
		/// <code>
		/// DataSet ds = helper.ExecuteDataset(connString, CommandType.StoredProcedure, "GetOrders");
		/// </code></example>
        /// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
        /// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
        /// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <returns>A DataSet containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接字符串 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <returns>A DataSet containing the resultset generated by the 命令</returns>
		public virtual DataSet 获得数据集(string 连接字符串, CommandType 命令类型, string 命令内容)
		{
			// Pass through the call providing null for the set of IDataParameters
			return 获得数据集(连接字符串, 命令类型, 命令内容, (IDataParameter[])null);
		}

		/// <summary>
		/// Execute an IDbCommand (that returns a resultset) against the database specified in the 连接 string 
		/// using the provided parameters.
		/// </summary>
		/// <example>
		/// <code>
		/// DataSet ds = helper.ExecuteDataset(connString, CommandType.StoredProcedure, "GetOrders", new IDbParameter("@prodid", 24));
		/// </code></example>
        /// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
        /// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
        /// <param name="命令内容">The stored procedure name or SQL 命令</param>
        /// <param name="命令参数集合">An array of IDbParamters used to execute the 命令</param>
		/// <returns>A DataSet containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接字符串 is null</exception>
		/// <exception cref="System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		public virtual DataSet 获得数据集(string 连接字符串, CommandType 命令类型, string 命令内容, params IDataParameter[] 命令参数集合)
		{
			if( 连接字符串 == null || 连接字符串.Length == 0 ) throw new ArgumentNullException( "连接字符串" );

			// Create & open an IDbConnection, and dispose of it after we are done
			using( IDbConnection connection = 获取连接( 连接字符串 ) )
			{
				connection.Open();

				// Call the overload that takes a 连接 in place of the 连接 string
				return 获得数据集(connection, 命令类型, 命令内容, 命令参数集合);
			}
		}

		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a resultset) against the database specified in 
		/// the 连接 string using the provided parameter values.  This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
		/// </summary>
		/// <remarks>
		/// This method provides no access to output parameters or the stored procedure's return 值 parameter.
		/// </remarks>
		/// <example>
		/// <code>
		/// DataSet ds = helper.ExecuteDataset(connString, "GetOrders", 24, 36);
		/// </code></example>
        /// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
        /// <param name="存储过程名称">The name of the stored procedure</param>
        /// <param name="参数值集合">An array of objects to be assigned as the input values of the stored procedure</param>
		/// <returns>A DataSet containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接字符串 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		public virtual DataSet 获得数据集(string 连接字符串, string 存储过程名称, params object[] 参数值集合)
		{
			if( 连接字符串 == null || 连接字符串.Length == 0 ) throw new ArgumentNullException( "连接字符串" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );
			
			// If we receive parameter values, we need to figure out where they go
			if ((参数值集合 != null) && (参数值集合.Length > 0)) 
			{
				IDataParameter[] iDataParameterValues = 获得数据参数(参数值集合.Length);

				// if we've been passed IDataParameters, don't do parameter discovery
				if (验证参数合法性(参数值集合, iDataParameterValues))
				{
					return 获得数据集(连接字符串, CommandType.StoredProcedure, 存储过程名称, iDataParameterValues);
				}
				else
				{
					// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
					bool includeReturnValue = 检验返回参数值(参数值集合);
					IDataParameter[] commandParameters = 获取存储过程参数设置(连接字符串, 存储过程名称, includeReturnValue);

					// Assign the provided values to these parameters based on parameter order
					分配参数值集合(commandParameters, 参数值集合);

					// Call the overload that takes an array of IDataParameters
					return 获得数据集(连接字符串, CommandType.StoredProcedure, 存储过程名称, commandParameters);
				}
			}
			else 
			{
				// Otherwise we can just call the SP without params
				return 获得数据集(连接字符串, CommandType.StoredProcedure, 存储过程名称);
			}
		}

		/// <summary>
		/// Execute an IDbCommand (that returns a resultset and takes no parameters) against the provided IDbConnection. 
		/// </summary>
		/// <example>
		/// <code>
		/// DataSet ds = helper.ExecuteDataset(conn, CommandType.StoredProcedure, "GetOrders");
		/// </code></example>
        /// <param name="连接">A valid IDbConnection</param>
        /// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
        /// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <returns>A DataSet containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		public virtual DataSet 获得数据集(IDbConnection 连接, CommandType 命令类型, string 命令内容)
		{
			// Pass through the call providing null for the set of IDataParameters
			return 获得数据集(连接, 命令类型, 命令内容, (IDataParameter[])null);
		}
		
		/// <summary>
		/// Execute an IDbCommand (that returns a resultset) against the specified IDbConnection 
		/// using the provided parameters.
		/// </summary>
		/// <example>
		/// <code>
		/// DataSet ds = helper.ExecuteDataset(conn, CommandType.StoredProcedure, "GetOrders", new IDataParameter("@prodid", 24));
		/// </code></example>
        /// <param name="连接">A valid IDbConnection</param>
        /// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
        /// <param name="命令内容">The stored procedure name or SQL 命令</param>
        /// <param name="命令参数集合">An array of IDataParameters used to execute the 命令</param>
		/// <returns>A DataSet containing the resultset generated by the 命令</returns>
		/// <exception cref="System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		public virtual DataSet 获得数据集(IDbConnection 连接, CommandType 命令类型, string 命令内容, params IDataParameter[] 命令参数集合)
		{
			if( 连接 == null ) throw new ArgumentNullException( "连接" );

			// Create a 命令 and prepare it for execution
			IDbCommand cmd = 连接.CreateCommand();
			bool mustCloseConnection = false;
			准备命令(cmd, 连接, (IDbTransaction)null, 命令类型, 命令内容, 命令参数集合, out mustCloseConnection );
			清除参数规则(cmd);
    			
			DataSet ds = 获得数据集(cmd);

			if( mustCloseConnection )
				连接.Close();

			// Return the DataSet
			return ds;
		}
		
		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a resultset) against the specified IDbConnection 
		/// using the provided parameter values.  This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
		/// </summary>
		/// <remarks>
		/// This method provides no access to output parameters or the stored procedure's return 值 parameter.
		/// </remarks>
		/// <example>
		/// <code>
		/// DataSet ds = helper.ExecuteDataset(conn, "GetOrders", 24, 36);
		/// </code></example>
        /// <param name="连接">A valid IDbConnection</param>
        /// <param name="存储过程名称">The name of the stored procedure</param>
        /// <param name="参数值集合">An array of objects to be assigned as the input values of the stored procedure</param>
		/// <returns>A DataSet containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		public virtual DataSet 获得数据集(IDbConnection 连接, string 存储过程名称, params object[] 参数值集合)
		{
			if( 连接 == null ) throw new ArgumentNullException( "连接" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			// If we receive parameter values, we need to figure out where they go
			if ((参数值集合 != null) && (参数值集合.Length > 0)) 
			{
				IDataParameter[] iDataParameterValues = 获得数据参数(参数值集合.Length);

				// if we've been passed IDataParameters, don't do parameter discovery
				if (验证参数合法性(参数值集合, iDataParameterValues))
				{
					return 获得数据集(连接, CommandType.StoredProcedure, 存储过程名称, iDataParameterValues);
				}
				else
				{
					// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
					bool includeReturnValue = 检验返回参数值(参数值集合);
					IDataParameter[] commandParameters = 获取存储过程参数设置(连接, 存储过程名称, includeReturnValue);

					// Assign the provided values to these parameters based on parameter order
					分配参数值集合(commandParameters, 参数值集合);

					// Call the overload that takes an array of IDataParameters
					return 获得数据集(连接, CommandType.StoredProcedure, 存储过程名称, commandParameters);
				}
			}
			else 
			{
				// Otherwise we can just call the SP without params
				return 获得数据集(连接, CommandType.StoredProcedure, 存储过程名称);
			}
		}

		/// <summary>
		/// Execute an IDbCommand (that returns a resultset and takes no parameters) against the provided IDbTransaction. 
		/// </summary>
		/// <example><code>
		///  DataSet ds = helper.ExecuteDataset(trans, CommandType.StoredProcedure, "GetOrders");
		/// </code></example>
        /// <param name="事务">A valid IDbTransaction</param>
        /// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
        /// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <returns>A DataSet containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务.Connection is null</exception>
		public virtual DataSet 获得数据集(IDbTransaction 事务, CommandType 命令类型, string 命令内容)
		{
			// Pass through the call providing null for the set of IDataParameters
			return 获得数据集(事务, 命令类型, 命令内容, (IDataParameter[])null);
		}
		
		/// <summary>
		/// Execute an IDbCommand (that returns a resultset) against the specified IDbTransaction
		/// using the provided parameters.
		/// </summary>
		/// <example>
		/// <code>
		/// DataSet ds = helper.ExecuteDataset(trans, CommandType.StoredProcedure, "GetOrders", new IDataParameter("@prodid", 24));
		/// </code></example>
        /// <param name="事务">A valid IDbTransaction</param>
        /// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
        /// <param name="命令内容">The stored procedure name or SQL 命令</param>
        /// <param name="命令参数集合">An array of IDataParameters used to execute the 命令</param>
		/// <returns>A DataSet containing the resultset generated by the 命令</returns>
		/// <exception cref="System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务.Connection is null</exception>
		public virtual DataSet 获得数据集(IDbTransaction 事务, CommandType 命令类型, string 命令内容, params IDataParameter[] 命令参数集合)
		{
			if( 事务 == null ) throw new ArgumentNullException( "事务" );
			if( 事务 != null && 事务.Connection == null ) throw new ArgumentException( "The 事务 was rolled back or commited, please provide an open 事务.", "事务" );

			// Create a 命令 and prepare it for execution
			IDbCommand cmd = 事务.Connection.CreateCommand();
			bool mustCloseConnection = false;
			准备命令(cmd, 事务.Connection, 事务, 命令类型, 命令内容, 命令参数集合, out mustCloseConnection );
			清除参数规则(cmd);
    		
			return 获得数据集(cmd);

		}
		
		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a resultset) against the specified 
		/// IDbTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
		/// </summary>
		/// <remarks>
		/// This method provides no access to output parameters or the stored procedure's return 值 parameter.
		/// </remarks>
		/// <example>
		/// <code>
		/// DataSet ds = helper.ExecuteDataset(tran, "GetOrders", 24, 36);
		/// </code></example>
        /// <param name="事务">A valid IDbTransaction</param>
        /// <param name="存储过程名称">The name of the stored procedure</param>
        /// <param name="参数值集合">An array of objects to be assigned as the input values of the stored procedure</param>
		/// <returns>A DataSet containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务.Connection is null</exception>
		public virtual DataSet 获得数据集(IDbTransaction 事务, string 存储过程名称, params object[] 参数值集合)
		{
			if( 事务 == null ) throw new ArgumentNullException( "事务" );
			if( 事务 != null && 事务.Connection == null ) throw new ArgumentException( "The 事务 was rolled back or commited, please provide an open 事务.", "事务" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );
			
			// If we receive parameter values, we need to figure out where they go
			if ((参数值集合 != null) && (参数值集合.Length > 0)) 
			{
				IDataParameter[] iDataParameterValues = 获得数据参数(参数值集合.Length);

				// if we've been passed IDataParameters, don't do parameter discovery
				if (验证参数合法性(参数值集合, iDataParameterValues))
				{
					return 获得数据集(事务, CommandType.StoredProcedure, 存储过程名称, iDataParameterValues);
				}
				else
				{

					// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
					bool includeReturnValue = 检验返回参数值(参数值集合);
					IDataParameter[] commandParameters = 获取存储过程参数设置(事务.Connection, 存储过程名称, includeReturnValue);

					// Assign the provided values to these parameters based on parameter order
					分配参数值集合(commandParameters, 参数值集合);

					// Call the overload that takes an array of IDataParameters
					return 获得数据集(事务, CommandType.StoredProcedure, 存储过程名称, commandParameters);
				}
			}
			else 
			{
				// Otherwise we can just call the SP without params
				return 获得数据集(事务, CommandType.StoredProcedure, 存储过程名称);
			}
		}

		#endregion ExecuteDataset

		#region 执行非查询命令

		/// <summary>
		/// Execute an IDbCommand (that returns no resultset) against the database
		/// </summary>
        /// <param name="命令">The IDbCommand to execute</param>
		/// <returns>An int representing the number of rows affected by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令 is null.</exception>
		public virtual int 执行非查询命令(IDbCommand 命令)
		{
			bool mustCloseConnection = false;

			// Clean Up Parameter Syntax
			清除参数规则(命令);

			if (命令.Connection.State != ConnectionState.Open)
			{
				命令.Connection.Open();
				mustCloseConnection = true;
			}
			
			if (命令 == null) throw new ArgumentNullException("命令");

			int returnVal;

			returnVal = 命令.ExecuteNonQuery();
			
			if (mustCloseConnection)
			{
				命令.Connection.Close();
			}

			return returnVal;
		}
		/// <summary>
		/// Execute an IDbCommand (that returns no resultset and takes no parameters) against the database specified in 
		/// the 连接 string
		/// </summary>
        /// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
        /// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
        /// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <returns>An int representing the number of rows affected by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接字符串 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		public virtual int 执行非查询命令(string 连接字符串, CommandType 命令类型, string 命令内容)
		{
			// Pass through the call providing null for the set of IDataParameters
			return 执行非查询命令(连接字符串, 命令类型, 命令内容, (IDataParameter[])null);
		}

		/// <summary>
		/// Execute an IDbCommand (that returns no resultset) against the database specified in the 连接 string 
		/// using the provided parameters
		/// </summary>
        /// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <param name="命令参数集合">An array of IDataParameters used to execute the 命令</param>
		/// <returns>An int representing the number of rows affected by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接字符串 is null</exception>
		/// <exception cref="System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		public virtual int 执行非查询命令(string 连接字符串, CommandType 命令类型, string 命令内容, params IDataParameter[] 命令参数集合)
		{
			if( 连接字符串 == null || 连接字符串.Length == 0 ) throw new ArgumentNullException( "连接字符串" );

			// Create & open an IDbConnection, and dispose of it after we are done
			using (IDbConnection connection = 获取连接(连接字符串))
			{
				connection.Open();

				// Call the overload that takes a 连接 in place of the 连接 string
				return 执行非查询命令(connection, 命令类型, 命令内容, 命令参数集合);
			}
		}

		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns no resultset) against the database specified in 
		/// the 连接 string using the provided parameter values.  This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
		/// </summary>
		/// <remarks>
		/// This method provides no access to output parameters or the stored procedure's return 值 parameter.
		/// 
		/// </remarks>
		/// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
		/// <param name="存储过程名称">The name of the stored prcedure</param>
		/// <param name="参数值集合">An array of objects to be assigned as the input values of the stored procedure</param>
		/// <returns>An int representing the number of rows affected by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接字符串 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		public virtual int 执行非查询命令(string 连接字符串, string 存储过程名称, params object[] 参数值集合)
		{
			if( 连接字符串 == null || 连接字符串.Length == 0 ) throw new ArgumentNullException( "连接字符串" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			// If we receive parameter values, we need to figure out where they go
			if ((参数值集合 != null) && (参数值集合.Length > 0)) 
			{
				IDataParameter[] iDataParameterValues = 获得数据参数(参数值集合.Length);

				// if we've been passed IDataParameters, don't do parameter discoveryu
				if (验证参数合法性(参数值集合, iDataParameterValues))
				{
					return 执行非查询命令(连接字符串, CommandType.StoredProcedure, 存储过程名称, iDataParameterValues);
				}
				else
				{
					// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
					bool includeReturnValue = 检验返回参数值(参数值集合);
					IDataParameter[] commandParameters = 获取存储过程参数设置(连接字符串, 存储过程名称, includeReturnValue);

					// Assign the provided values to these parameters based on parameter order
					分配参数值集合(commandParameters, 参数值集合);

					// Call the overload that takes an array of IDataParameters
					return 执行非查询命令(连接字符串, CommandType.StoredProcedure, 存储过程名称, commandParameters);
				}
			}
			else 
			{
				// Otherwise we can just call the SP without params
				return 执行非查询命令(连接字符串, CommandType.StoredProcedure, 存储过程名称);
			}
		}

		/// <summary>
		/// Execute an IDbCommand (that returns no resultset and takes no parameters) against the provided IDbConnection. 
		/// </summary>
		/// <param name="连接">A valid IDbConnection</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <returns>An int representing the number of rows affected by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		public virtual int 执行非查询命令(IDbConnection 连接, CommandType 命令类型, string 命令内容)
		{
			// Pass through the call providing null for the set of IDataParameters
			return 执行非查询命令(连接, 命令类型, 命令内容, (IDataParameter[])null);
		}

		/// <summary>
		/// Execute an IDbCommand (that returns no resultset) against the specified IDbConnection 
		/// using the provided parameters.
		/// </summary>
		/// <remarks>
		/// </remarks>
		/// <param name="连接">A valid IDbConnection</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <param name="命令参数集合">An array of IDbParamters used to execute the 命令</param>
		/// <returns>An int representing the number of rows affected by the 命令</returns>
		/// <exception cref="System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		public virtual int 执行非查询命令(IDbConnection 连接, CommandType 命令类型, string 命令内容, params IDataParameter[] 命令参数集合)
		{	
			if( 连接 == null ) throw new ArgumentNullException( "连接" );

			// Create a 命令 and prepare it for execution
			IDbCommand cmd = 连接.CreateCommand();
			bool mustCloseConnection = false;
			准备命令(cmd, 连接, (IDbTransaction)null, 命令类型, 命令内容, 命令参数集合, out mustCloseConnection );
			清除参数规则(cmd);
    		
			// Finally, execute the 命令
			int retval = 执行非查询命令(cmd);
    		
			// Detach the IDataParameters from the 命令 object, so they can be used again
			// don't do this...screws up output parameters -- cjbreisch
			// 命令.Parameters.Clear();
			if( mustCloseConnection )
				连接.Close();
			return retval;
		}

		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns no resultset) against the specified IDbConnection 
		/// using the provided parameter values.  This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
		/// </summary>
		/// <remarks>
		/// This method provides no access to output parameters or the stored procedure's return 值 parameter.
		/// 
		/// </remarks>
		/// <param name="连接">A valid IDbConnection</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="参数值集合">An array of objects to be assigned as the input values of the stored procedure</param>
		/// <returns>An int representing the number of rows affected by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		public virtual int 执行非查询命令(IDbConnection 连接, string 存储过程名称, params object[] 参数值集合)
		{
			if( 连接 == null ) throw new ArgumentNullException( "连接" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			// If we receive parameter values, we need to figure out where they go
			if ((参数值集合 != null) && (参数值集合.Length > 0)) 
			{
				IDataParameter[] iDataParameterValues = 获得数据参数(参数值集合.Length);

				// if we've been passed IDataParameters, don't do parameter discoveryu
				if (验证参数合法性(参数值集合, iDataParameterValues))
				{
					return 执行非查询命令(连接, CommandType.StoredProcedure, 存储过程名称, iDataParameterValues);
				}
				else
				{

					// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
					bool includeReturnValue = 检验返回参数值(参数值集合);
					IDataParameter[] commandParameters = 获取存储过程参数设置(连接, 存储过程名称, includeReturnValue);

					// Assign the provided values to these parameters based on parameter order
					分配参数值集合(commandParameters, 参数值集合);

					// Call the overload that takes an array of IDataParameters
					return 执行非查询命令(连接, CommandType.StoredProcedure, 存储过程名称, commandParameters);
				}
			}
			else 
			{
				// Otherwise we can just call the SP without params
				return 执行非查询命令(连接, CommandType.StoredProcedure, 存储过程名称);
			}
		}

		/// <summary>
		/// Execute an IDbCommand (that returns no resultset and takes no parameters) against the provided IDbTransaction. 
		/// </summary>
		/// <param name="事务">A valid IDbTransaction</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <returns>An int representing the number of rows affected by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务.Connection is null</exception>
		public virtual int 执行非查询命令(IDbTransaction 事务, CommandType 命令类型, string 命令内容)
		{
			// Pass through the call providing null for the set of IDataParameters
			return 执行非查询命令(事务, 命令类型, 命令内容, (IDataParameter[])null);
		}

		/// <summary>
		/// Execute an IDbCommand (that returns no resultset) against the specified IDbTransaction
		/// using the provided parameters.
		/// </summary>
		/// <param name="事务">A valid IDbTransaction</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <param name="命令参数集合">An array of IDataParameters used to execute the 命令</param>
		/// <returns>An int representing the number of rows affected by the 命令</returns>
		/// <exception cref="System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务.Connection is null</exception>
		public virtual int 执行非查询命令(IDbTransaction 事务, CommandType 命令类型, string 命令内容, params IDataParameter[] 命令参数集合)
		{
			if( 事务 == null ) throw new ArgumentNullException( "事务" );
			if( 事务 != null && 事务.Connection == null ) throw new ArgumentException( "The 事务 was rolled back or commited, please provide an open 事务.", "事务" );

			// Create a 命令 and prepare it for execution
			IDbCommand cmd = 事务.Connection.CreateCommand(); 
			bool mustCloseConnection = false;
			准备命令(cmd, 事务.Connection, 事务, 命令类型, 命令内容, 命令参数集合, out mustCloseConnection );
			清除参数规则(cmd);
    			
			// Finally, execute the 命令
			int retval = 执行非查询命令(cmd);
    			
			// Detach the IDataParameters from the 命令 object, so they can be used again
			// don't do this...screws up output parameters -- cjbreisch
			// 命令.Parameters.Clear();
			return retval;
		}

		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns no resultset) against the specified 
		/// IDbTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
		/// </summary>
		/// <remarks>
		/// This method provides no access to output parameters or the stored procedure's return 值 parameter.
		/// </remarks>
		/// <param name="事务">A valid IDbTransaction</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="参数值集合">An array of objects to be assigned as the input values of the stored procedure</param>
		/// <returns>An int representing the number of rows affected by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务.Connection is null</exception>
		public virtual int 执行非查询命令(IDbTransaction 事务, string 存储过程名称, params object[] 参数值集合)
		{
			if( 事务 == null ) throw new ArgumentNullException( "事务" );
			if( 事务 != null && 事务.Connection == null ) throw new ArgumentException( "The 事务 was rolled back or commited, please provide an open 事务.", "事务" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			// If we receive parameter values, we need to figure out where they go
			if ((参数值集合 != null) && (参数值集合.Length > 0)) 
			{
				IDataParameter[] iDataParameterValues = 获得数据参数(参数值集合.Length);

				// if we've been passed IDataParameters, don't do parameter discoveryu
				if (验证参数合法性(参数值集合, iDataParameterValues))
				{
					return 执行非查询命令(事务, CommandType.StoredProcedure, 存储过程名称, iDataParameterValues);
				}
				else
				{

					// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
					bool includeReturnValue = 检验返回参数值(参数值集合);
					IDataParameter[] commandParameters = 获取存储过程参数设置(事务.Connection, 存储过程名称, includeReturnValue);

					// Assign the provided values to these parameters based on parameter order
					分配参数值集合(commandParameters, 参数值集合);

					// Call the overload that takes an array of IDbParameters
					return 执行非查询命令(事务, CommandType.StoredProcedure, 存储过程名称, commandParameters);
				}
			}
			else 
			{
				// Otherwise we can just call the SP without params
				return 执行非查询命令(事务, CommandType.StoredProcedure, 存储过程名称);
			}
		}

		#endregion 执行非查询命令

		#region 获得读取器
		/// <summary>
		/// Execute an IDbCommand (that returns a resultset) against the database specified in 
		/// the 连接 string. 
		/// </summary>
		/// <param name="命令">The IDbCommand object to use</param>
		/// <returns>A IDataReader containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令 is null.</exception>
		public virtual IDataReader 获得读取器(IDbCommand 命令)
		{
			return 获得读取器(命令, 连接权限.外部);
		}

		/// <summary>
		/// Execute an IDbCommand (that returns a resultset) against the database specified in 
		/// the 连接 string. 
		/// </summary>
		/// <param name="命令">The IDbCommand object to use</param>
		/// <param name="连接权限">Enum indicating whether the 连接 was created internally or externally.</param>
		/// <returns>A IDataReader containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令 is null.</exception>
		protected virtual IDataReader 获得读取器(IDbCommand 命令, 连接权限 连接权限)
		{
			// Clean Up Parameter Syntax
			清除参数规则(命令);

			if (命令.Connection.State != ConnectionState.Open)
			{
				命令.Connection.Open();
				连接权限 = 连接权限.内部;
			}

			// Create a reader
			IDataReader dataReader;

			// Call 获得读取器 with the appropriate CommandBehavior
			if (连接权限 == 连接权限.外部)
			{
				dataReader = 命令.ExecuteReader();
			}
			else
			{
				try
				{
					dataReader = 命令.ExecuteReader(CommandBehavior.CloseConnection);
				}
				catch (Exception ex)
				{
					// Don't just throw ex.  It changes the call stack.  But we want the ex around for debugging, so...
					Debug.WriteLine(ex);
					throw;
				}
			}
			
			清除命令( 命令 );

			return dataReader;
		}
		/// <summary>
		/// Create and prepare an IDbCommand, and call 获得读取器 with the appropriate CommandBehavior.
		/// </summary>
		/// <remarks>
		/// If we created and opened the 连接, we want the 连接 to be closed when the DataReader is closed.
		/// 
		/// If the caller provided the 连接, we want to leave it to them to manage.
		/// </remarks>
		/// <param name="连接">A valid IDbConnection, on which to execute this 命令</param>
		/// <param name="事务">A valid IDbTransaction, or 'null'</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <param name="命令参数集合">An array of IDataParameters to be associated with the 命令 or 'null' if no parameters are required</param>
		/// <param name="连接权限">Indicates whether the 连接 parameter was provided by the caller, or created by AdoHelper</param>
		/// <returns>IDataReader containing the results of the 命令</returns>
		/// <exception cref="System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		private IDataReader 获得读取器(IDbConnection 连接, IDbTransaction 事务, CommandType 命令类型, string 命令内容, IDataParameter[] 命令参数集合, 连接权限 连接权限)
		{	
			if( 连接 == null ) throw new ArgumentNullException( "连接" );

			bool mustCloseConnection = false;
			// Create a 命令 and prepare it for execution
			IDbCommand cmd = 连接.CreateCommand();
			try
			{
				准备命令(cmd, 连接, 事务, 命令类型, 命令内容, 命令参数集合, out mustCloseConnection );
				清除参数规则(cmd);
			
				// override conenctionOwnership if we created the 连接 in PrepareCommand -- cjbreisch
				if (mustCloseConnection)
				{
					连接权限 = 连接权限.内部;
				}

				// Create a reader
				IDataReader dataReader;

				dataReader = 获得读取器(cmd, 连接权限);
				
				清除命令( cmd );

				return dataReader;
			}
			catch
			{
				if( mustCloseConnection )
					连接.Close();
				throw;
			}
		}

		/// <summary>
		/// Execute an IDbCommand (that returns a resultset and takes no parameters) against the database specified in 
		/// the 连接 string. 
		/// </summary>
		/// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <returns>A IDataReader containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接字符串 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		public virtual IDataReader 获得读取器(string 连接字符串, CommandType 命令类型, string 命令内容)
		{
			// Pass through the call providing null for the set of IDataParameters
			return 获得读取器(连接字符串, 命令类型, 命令内容, (IDataParameter[])null);
		}

		/// <summary>
		/// Execute an IDbCommand (that returns a resultset) against the database specified in the 连接 string 
		/// using the provided parameters.
		/// </summary>
		/// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <param name="命令参数集合">An array of IDataParameters used to execute the 命令</param>
		/// <returns>A IDataReader containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接字符串 is null</exception>
		/// <exception cref="System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		public virtual IDataReader 获得读取器(string 连接字符串, CommandType 命令类型, string 命令内容, params IDataParameter[] 命令参数集合)
		{
			if( 连接字符串 == null || 连接字符串.Length == 0 ) throw new ArgumentNullException( "连接字符串" );
			IDbConnection connection = null;
			try
			{
				connection = 获取连接(连接字符串);
				connection.Open();

				// Call the private overload that takes an internally owned 连接 in place of the 连接 string
				return 获得读取器(connection, null, 命令类型, 命令内容, 命令参数集合, 连接权限.内部);
			}
			catch
			{
				// If we fail to return the IDataReader, we need to close the 连接 ourselves
				if( connection != null ) connection.Close();
				throw;
			}
            
		}

		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a resultset) against the database specified in 
		/// the 连接 string using the provided parameter values.  This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
		/// </summary>
		/// <remarks>
		/// This method provides no access to output parameters or the stored procedure's return 值 parameter.
		/// </remarks>
		/// <example>
		/// <code>
		/// IDataReader dr = helper.获得读取器(connString, "GetOrders", 24, 36);
		/// </code></example>
		/// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="参数值集合">An array of objects to be assigned as the input values of the stored procedure</param>
		/// <returns>an IDataReader containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接字符串 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		public virtual IDataReader 获得读取器(string 连接字符串, string 存储过程名称, params object[] 参数值集合)
		{
			if( 连接字符串 == null || 连接字符串.Length == 0 ) throw new ArgumentNullException( "连接字符串" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );
			
			// If we receive parameter values, we need to figure out where they go
			if ((参数值集合 != null) && (参数值集合.Length > 0)) 
			{
				IDataParameter[] iDataParameterValues = 获得数据参数(参数值集合.Length);

				// if we've been passed IDataParameters, don't do parameter discovery
				if (验证参数合法性(参数值集合, iDataParameterValues))
				{
					return 获得读取器(连接字符串, CommandType.StoredProcedure, 存储过程名称, iDataParameterValues);
				}
				else
				{

					bool includeReturnValue = 检验返回参数值(参数值集合);
					IDataParameter[] commandParameters = 获取存储过程参数设置(连接字符串, 存储过程名称, includeReturnValue);

					分配参数值集合(commandParameters, 参数值集合);

					return 获得读取器(连接字符串, CommandType.StoredProcedure, 存储过程名称, commandParameters);
				}
			}
			else 
			{
				// Otherwise we can just call the SP without params
				return 获得读取器(连接字符串, CommandType.StoredProcedure, 存储过程名称);
			}
		}

		/// <summary>
		/// Execute an IDbCommand (that returns a resultset and takes no parameters) against the provided IDbConnection. 
		/// </summary>
		/// <example>
		/// <code>
		/// IDataReader dr = helper.获得读取器(conn, CommandType.StoredProcedure, "GetOrders");
		/// </code></example>
		/// <param name="连接">A valid IDbConnection</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <returns>an IDataReader containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		public virtual IDataReader 获得读取器(IDbConnection 连接, CommandType 命令类型, string 命令内容)
		{
			// Pass through the call providing null for the set of IDataParameters
			return 获得读取器(连接, 命令类型, 命令内容, (IDataParameter[])null);
		}

		/// <summary>
		/// Execute an IDbCommand (that returns a resultset) against the specified IDbConnection 
		/// using the provided parameters.
		/// </summary>
		/// <example>
		/// <code>
		/// IDataReader dr = helper.获得读取器(conn, CommandType.StoredProcedure, "GetOrders", new IDataParameter("@prodid", 24));
		/// </code></example>
		/// <param name="连接">A valid IDbConnection</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <param name="命令参数集合">An array of IDataParameters used to execute the 命令</param>
		/// <returns>an IDataReader containing the resultset generated by the 命令</returns>
		/// <exception cref="System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		public virtual IDataReader 获得读取器(IDbConnection 连接, CommandType 命令类型, string 命令内容, params IDataParameter[] 命令参数集合)
		{
			// Pass through the call to the private overload using a null 事务 值 and an externally owned 连接
			return 获得读取器(连接, (IDbTransaction)null, 命令类型, 命令内容, 命令参数集合, 连接权限.外部);
		}

		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a resultset) against the specified IDbConnection 
		/// using the provided parameter values.  This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
		/// </summary>
		/// <remarks>
		/// This method provides no access to output parameters or the stored procedure's return 值 parameter.
		/// </remarks>
		/// <example>
		/// <code>
		/// IDataReader dr = helper.获得读取器(conn, "GetOrders", 24, 36);
		/// </code></example>
		/// <param name="连接">A valid IDbConnection</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="参数值集合">An array of objects to be assigned as the input values of the stored procedure</param>
		/// <returns>an IDataReader containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		public virtual IDataReader 获得读取器(IDbConnection 连接, string 存储过程名称, params object[] 参数值集合)
		{
			if( 连接 == null ) throw new ArgumentNullException( "连接" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			// If we receive parameter values, we need to figure out where they go
			if ((参数值集合 != null) && (参数值集合.Length > 0)) 
			{
				IDataParameter[] iDataParameterValues = 获得数据参数(参数值集合.Length);

				// if we've been passed IDataParameters, don't do parameter discovery
				if (验证参数合法性(参数值集合, iDataParameterValues))
				{
					return 获得读取器(连接, CommandType.StoredProcedure, 存储过程名称, iDataParameterValues);
				}
				else
				{

					bool includeReturnValue = 检验返回参数值(参数值集合);
					IDataParameter[] commandParameters = 获取存储过程参数设置(连接, 存储过程名称, includeReturnValue);

					分配参数值集合(commandParameters, 参数值集合);

					return 获得读取器(连接, CommandType.StoredProcedure, 存储过程名称, commandParameters);
				}
			}
			else 
			{
				// Otherwise we can just call the SP without params
				return 获得读取器(连接, CommandType.StoredProcedure, 存储过程名称);
			}
		}

		/// <summary>
		/// Execute an IDbCommand (that returns a resultset and takes no parameters) against the provided IDbTransaction. 
		/// </summary>
		/// <example><code>
		///  IDataReader dr = helper.获得读取器(trans, CommandType.StoredProcedure, "GetOrders");
		/// </code></example>
		/// <param name="事务">A valid IDbTransaction</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <returns>A IDataReader containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		public virtual IDataReader 获得读取器(IDbTransaction 事务, CommandType 命令类型, string 命令内容)
		{
			// Pass through the call providing null for the set of IDataParameters
			return 获得读取器(事务, 命令类型, 命令内容, (IDataParameter[])null);
		}

		/// <summary>
		/// Execute an IDbCommand (that returns a resultset) against the specified IDbTransaction
		/// using the provided parameters.
		/// </summary>
		/// <example>
		/// <code>
		/// IDataReader dr = helper.获得读取器(trans, CommandType.StoredProcedure, "GetOrders", new IDataParameter("@prodid", 24));
		/// </code></example>
		/// <param name="事务">A valid IDbTransaction</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <param name="命令参数集合">An array of IDataParameters used to execute the 命令</param>
		/// <returns>A IDataReader containing the resultset generated by the 命令</returns>
		public virtual IDataReader 获得读取器(IDbTransaction 事务, CommandType 命令类型, string 命令内容, params IDataParameter[] 命令参数集合)
		{
			if( 事务 == null ) throw new ArgumentNullException( "事务" );
			if( 事务 != null && 事务.Connection == null ) throw new ArgumentException( "The 事务 was rolled back or commited, please provide an open 事务.", "事务" );

			// Pass through to private overload, indicating that the 连接 is owned by the caller
			return 获得读取器(事务.Connection, 事务, 命令类型, 命令内容, 命令参数集合, 连接权限.外部);
		}

		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a resultset) against the specified
		/// IDbTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
		/// </summary>
		/// <remarks>
		/// This method provides no access to output parameters or the stored procedure's return 值 parameter.
		/// </remarks>
		/// <example>
		/// <code>
		/// IDataReader dr = helper.获得读取器(tran, "GetOrders", 24, 36);
		/// </code></example>
		/// <param name="事务">A valid IDbTransaction</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="参数值集合">An array of objects to be assigned as the input values of the stored procedure</param>
		/// <returns>an IDataReader containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务.Connection is null</exception>
		public virtual IDataReader 获得读取器(IDbTransaction 事务, string 存储过程名称, params object[] 参数值集合)
		{
			if( 事务 == null ) throw new ArgumentNullException( "事务" );
			if( 事务 != null && 事务.Connection == null ) throw new ArgumentException( "The 事务 was rolled back or commited, please provide an open 事务.", "事务" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			// If we receive parameter values, we need to figure out where they go
			if ((参数值集合 != null) && (参数值集合.Length > 0)) 
			{
				IDataParameter[] iDataParameterValues = 获得数据参数(参数值集合.Length);

				// if we've been passed IDataParameters, don't do parameter discovery
				if (验证参数合法性(参数值集合, iDataParameterValues))
				{
					return 获得读取器(事务, CommandType.StoredProcedure, 存储过程名称, iDataParameterValues);
				}
				else
				{

					bool includeReturnValue = 检验返回参数值(参数值集合);
					IDataParameter[] commandParameters = 获取存储过程参数设置(事务.Connection, 存储过程名称, includeReturnValue);

					分配参数值集合(commandParameters, 参数值集合);

					return 获得读取器(事务, CommandType.StoredProcedure, 存储过程名称, commandParameters);
				}
			}
			else 
			{
				// Otherwise we can just call the SP without params
				return 获得读取器(事务, CommandType.StoredProcedure, 存储过程名称);
			}
		}

		#endregion 获得读取器

		#region 执行单值查询
		/// <summary>
		/// Execute an IDbCommand (that returns a 1x1 resultset) against the database specified in 
		/// the 连接 string. 
		/// </summary>
		/// <param name="命令">The IDbCommand to execute</param>
		/// <returns>An object containing the 值 in the 1x1 resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令 is null.</exception>
		public virtual object 执行单值查询(IDbCommand 命令)
		{
			bool mustCloseConnection = false;

			// Clean Up Parameter Syntax
			清除参数规则(命令);

			if (命令.Connection.State != ConnectionState.Open)
			{
				命令.Connection.Open();
				mustCloseConnection = true;
			}

			// Execute the 命令 & return the results
			object retval = 命令.ExecuteScalar();
    			
			// Detach the IDataParameters from the 命令 object, so they can be used again
			// don't do this...screws up output params -- cjbreisch
			// 命令.Parameters.Clear();

			if (mustCloseConnection)
			{
				命令.Connection.Close();
			}

			return retval;
		}

		/// <summary>
		/// Execute an IDbCommand (that returns a 1x1 resultset and takes no parameters) against the database specified in 
		/// the 连接 string. 
		/// </summary>
		/// <example>
		/// <code>
		/// int orderCount = (int)helper.执行单值查询(connString, CommandType.StoredProcedure, "GetOrderCount");
		/// </code></example>
		/// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <returns>An object containing the 值 in the 1x1 resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接字符串 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		public virtual object 执行单值查询(string 连接字符串, CommandType 命令类型, string 命令内容)
		{
			// Pass through the call providing null for the set of IDataParameters
			return 执行单值查询(连接字符串, 命令类型, 命令内容, (IDataParameter[])null);
		}

		/// <summary>
		/// Execute an IDbCommand (that returns a 1x1 resultset) against the database specified in the 连接 string 
		/// using the provided parameters.
		/// </summary>
		/// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <param name="命令参数集合">An array of IDataParameters used to execute the 命令</param>
		/// <returns>An object containing the 值 in the 1x1 resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接字符串 is null</exception>
		/// <exception cref="System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		public virtual object 执行单值查询(string 连接字符串, CommandType 命令类型, string 命令内容, params IDataParameter[] 命令参数集合)
		{
			if( 连接字符串 == null || 连接字符串.Length == 0 ) throw new ArgumentNullException( "连接字符串" );
			// Create & open an IDbConnection, and dispose of it after we are done
			IDbConnection connection = null;
			try
			{
				connection = 获取连接(连接字符串);
				connection.Open();

				// Call the overload that takes a 连接 in place of the 连接 string
				return 执行单值查询(connection, 命令类型, 命令内容, 命令参数集合);
			}
			finally
			{
				IDisposable id = connection as IDisposable;
				if( id != null ) id.Dispose();
			}
		}

		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a 1x1 resultset) against the database specified in 
		/// the 连接 string using the provided parameter values.  This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
		/// </summary>
		/// <remarks>
		/// This method provides no access to output parameters or the stored procedure's return 值 parameter.
		/// </remarks>
		/// <example>
		/// <code>
		/// int orderCount = (int)helper.执行单值查询(connString, "GetOrderCount", 24, 36);
		/// </code></example>
		/// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="参数值集合">An array of objects to be assigned as the input values of the stored procedure</param>
		/// <returns>An object containing the 值 in the 1x1 resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接字符串 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		public virtual object 执行单值查询(string 连接字符串, string 存储过程名称, params object[] 参数值集合)
		{
			if( 连接字符串 == null || 连接字符串.Length == 0 ) throw new ArgumentNullException( "连接字符串" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );
			
			// If we receive parameter values, we need to figure out where they go
			if ((参数值集合 != null) && (参数值集合.Length > 0)) 
			{
				IDataParameter[] iDataParameterValues = 获得数据参数(参数值集合.Length);

				// if we've been passed IDataParameters, don't do parameter discovery
				if (验证参数合法性(参数值集合, iDataParameterValues))
				{
					return 执行单值查询(连接字符串, CommandType.StoredProcedure, 存储过程名称, iDataParameterValues);
				}
				else
				{

					// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
					bool includeReturnValue = 检验返回参数值(参数值集合);
					IDataParameter[] commandParameters = 获取存储过程参数设置(连接字符串, 存储过程名称, includeReturnValue);

					// Assign the provided values to these parameters based on parameter order
					分配参数值集合(commandParameters, 参数值集合);

					// Call the overload that takes an array of IDataParameters
					return 执行单值查询(连接字符串, CommandType.StoredProcedure, 存储过程名称, commandParameters);
				}
			}
			else 
			{
				// Otherwise we can just call the SP without params
				return 执行单值查询(连接字符串, CommandType.StoredProcedure, 存储过程名称);
			}
		}

		/// <summary>
		/// Execute an IDbCommand (that returns a 1x1 resultset and takes no parameters) against the provided IDbConnection. 
		/// </summary>
		/// <example>
		/// <code>
		/// int orderCount = (int)helper.执行单值查询(conn, CommandType.StoredProcedure, "GetOrderCount");
		/// </code></example>
		/// <param name="连接">A valid IDbConnection</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <returns>An object containing the 值 in the 1x1 resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		public virtual object 执行单值查询(IDbConnection 连接, CommandType 命令类型, string 命令内容)
		{
			// Pass through the call providing null for the set of IDbParameters
			return 执行单值查询(连接, 命令类型, 命令内容, (IDataParameter[])null);
		}

		/// <summary>
		/// Execute an IDbCommand (that returns a 1x1 resultset) against the specified IDbConnection 
		/// using the provided parameters.
		/// </summary>
		/// <param name="连接">A valid IDbConnection</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <param name="命令参数集合">An array of IDataParameters used to execute the 命令</param>
		/// <returns>An object containing the 值 in the 1x1 resultset generated by the 命令</returns>
		/// <exception cref="System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		public virtual object 执行单值查询(IDbConnection 连接, CommandType 命令类型, string 命令内容, params IDataParameter[] 命令参数集合)
		{
			if( 连接 == null ) throw new ArgumentNullException( "连接" );

			// Create a 命令 and prepare it for execution
			IDbCommand cmd = 连接.CreateCommand();

			bool mustCloseConnection = false;
			准备命令(cmd, 连接, (IDbTransaction)null, 命令类型, 命令内容, 命令参数集合, out mustCloseConnection );
			清除参数规则(cmd);
    			
			// Execute the 命令 & return the results
			object retval = 执行单值查询(cmd);
    			
			// Detach the IDataParameters from the 命令 object, so they can be used again
			// don't do this...screws up output parameters -- cjbreisch
			// 命令.Parameters.Clear();

			if( mustCloseConnection )
				连接.Close();

			return retval;
		}

		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a 1x1 resultset) against the specified IDbConnection 
		/// using the provided parameter values.  This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
		/// </summary>
		/// <remarks>
		/// This method provides no access to output parameters or the stored procedure's return 值 parameter.
		/// </remarks>
		/// <example>
		/// <code>
		/// int orderCount = (int)helper.执行单值查询(conn, "GetOrderCount", 24, 36);
		/// </code></example>
		/// <param name="连接">A valid IDbConnection</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="参数值集合">An array of objects to be assigned as the input values of the stored procedure</param>
		/// <returns>An object containing the 值 in the 1x1 resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		public virtual object 执行单值查询(IDbConnection 连接, string 存储过程名称, params object[] 参数值集合)
		{
			if( 连接 == null ) throw new ArgumentNullException( "连接" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			// If we receive parameter values, we need to figure out where they go
			if ((参数值集合 != null) && (参数值集合.Length > 0)) 
			{
				IDataParameter[] iDataParameterValues = 获得数据参数(参数值集合.Length);

				// if we've been passed IDataParameters, don't do parameter discovery
				if (验证参数合法性(参数值集合, iDataParameterValues))
				{
					return 执行单值查询(连接, CommandType.StoredProcedure, 存储过程名称, iDataParameterValues);
				}
				else
				{

					// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
					bool includeReturnValue = 检验返回参数值(参数值集合);
					IDataParameter[] commandParameters = 获取存储过程参数设置(连接, 存储过程名称, includeReturnValue);

					// Assign the provided values to these parameters based on parameter order
					分配参数值集合(commandParameters, 参数值集合);

					// Call the overload that takes an array of IDataParameters
					return 执行单值查询(连接, CommandType.StoredProcedure, 存储过程名称, commandParameters);
				}
			}
			else 
			{
				// Otherwise we can just call the SP without params
				return 执行单值查询(连接, CommandType.StoredProcedure, 存储过程名称);
			}
		}

		/// <summary>
		/// Execute an IDbCommand (that returns a 1x1 resultset and takes no parameters) against the provided IDbTransaction. 
		/// </summary>
		/// <example>
		/// <code>
		/// int orderCount = (int)helper.执行单值查询(tran, CommandType.StoredProcedure, "GetOrderCount");
		/// </code></example>
		/// <param name="事务">A valid IDbTransaction</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <returns>An object containing the 值 in the 1x1 resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		public virtual object 执行单值查询(IDbTransaction 事务, CommandType 命令类型, string 命令内容)
		{
			// Pass through the call providing null for the set of IDataParameters
			return 执行单值查询(事务, 命令类型, 命令内容, (IDataParameter[])null);
		}

		/// <summary>
		/// Execute an IDbCommand (that returns a 1x1 resultset) against the specified IDbTransaction
		/// using the provided parameters.
		/// </summary>
		/// <param name="事务">A valid IDbTransaction</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <param name="命令参数集合">An array of IDbParamters used to execute the 命令</param>
		/// <returns>An object containing the 值 in the 1x1 resultset generated by the 命令</returns>
		/// <exception cref="System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务.Connection is null</exception>
		public virtual object 执行单值查询(IDbTransaction 事务, CommandType 命令类型, string 命令内容, params IDataParameter[] 命令参数集合)
		{
			if( 事务 == null ) throw new ArgumentNullException( "事务" );
			if( 事务 != null && 事务.Connection == null ) throw new ArgumentException( "The 事务 was rolled back or commited, please provide an open 事务.", "事务" );

			// Create a 命令 and prepare it for execution
			IDbCommand cmd = 事务.Connection.CreateCommand();
			bool mustCloseConnection = false;
			准备命令(cmd, 事务.Connection, 事务, 命令类型, 命令内容, 命令参数集合, out mustCloseConnection );
			清除参数规则(cmd);
    			
			// Execute the 命令 & return the results
			object retval = 执行单值查询(cmd);
    			
			// Detach the IDataParameters from the 命令 object, so they can be used again
			// don't do this...screws up output parameters -- cjbreisch
			// 命令.Parameters.Clear();
			return retval;
		}

		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a 1x1 resultset) against the specified
		/// IDbTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
		/// </summary>
		/// <remarks>
		/// This method provides no access to output parameters or the stored procedure's return 值 parameter.
		/// </remarks>
		/// <example>
		/// <code>
		/// int orderCount = (int)helper.执行单值查询(tran, "GetOrderCount", 24, 36);
		/// </code></example>
		/// <param name="事务">A valid IDbTransaction</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="参数值集合">An array of objects to be assigned as the input values of the stored procedure</param>
		/// <returns>An object containing the 值 in the 1x1 resultset generated by the 命令</returns>
		/// <exception cref="System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务.Connection is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the 事务 is rolled back or commmitted</exception>
		public virtual object 执行单值查询(IDbTransaction 事务, string 存储过程名称, params object[] 参数值集合)
		{
			if( 事务 == null ) throw new ArgumentNullException( "事务" );
			if( 事务 != null && 事务.Connection == null ) throw new ArgumentException( "The 事务 was rolled back or commited, please provide an open 事务.", "事务" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			// If we receive parameter values, we need to figure out where they go
			if ((参数值集合 != null) && (参数值集合.Length > 0)) 
			{
				IDataParameter[] iDataParameterValues = 获得数据参数(参数值集合.Length);

				// if we've been passed IDataParameters, don't do parameter discovery
				if (验证参数合法性(参数值集合, iDataParameterValues))
				{
					return 执行单值查询(事务, CommandType.StoredProcedure, 存储过程名称, iDataParameterValues);
				}
				else
				{
					// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
					bool includeReturnValue = 检验返回参数值(参数值集合);
					IDataParameter[] commandParameters = 获取存储过程参数设置(事务.Connection, 存储过程名称, includeReturnValue);

					// Assign the provided values to these parameters based on parameter order
					分配参数值集合(commandParameters, 参数值集合);

					// Call the overload that takes an array of IDataParameters
					return 执行单值查询(事务, CommandType.StoredProcedure, 存储过程名称, commandParameters);
				}
			}
			else 
			{
				// Otherwise we can just call the SP without params
				return 执行单值查询(事务, CommandType.StoredProcedure, 存储过程名称);
			}
		}

		#endregion 执行单值查询	

		#region 获得XML读取器
		/// <summary>
		/// Execute an IDbCommand (that returns a resultset and takes no parameters) against the provided IDbConnection. 
		/// </summary>
		/// <example>
		/// <code>
		/// XmlReader r = helper.获得XML读取器(conn, CommandType.StoredProcedure, "GetOrders");
		/// </code></example>
		/// <param name="连接">A valid IDbConnection</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令 using "FOR XML AUTO"</param>
		/// <returns>An XmlReader containing the resultset generated by the 命令</returns>
		public XmlReader 获得XML读取器(IDbConnection 连接, CommandType 命令类型, string 命令内容)
		{
			// Pass through the call providing null for the set of IDataParameters
			return 获得XML读取器(连接, 命令类型, 命令内容, (IDataParameter[])null);
		}

		/// <summary>
		/// Execute an IDbCommand (that returns a resultset) against the specified IDbConnection 
		/// using the provided parameters.
		/// </summary>
		/// <example>
		/// <code>
		/// XmlReader r = helper.获得XML读取器(conn, CommandType.StoredProcedure, "GetOrders", GetParameter("@prodid", 24));
		/// </code></example>
		/// <param name="连接">A valid IDbConnection</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令 using "FOR XML AUTO"</param>
		/// <param name="命令参数集合">An array of IDataParameters used to execute the 命令</param>
		/// <returns>An XmlReader containing the resultset generated by the 命令</returns>
		/// <exception cref="System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		public XmlReader 获得XML读取器(IDbConnection 连接, CommandType 命令类型, string 命令内容, params IDataParameter[] 命令参数集合)
		{
			if( 连接 == null ) throw new ArgumentNullException( "连接" );

			bool mustCloseConnection = false;
			// Create a 命令 and prepare it for execution
			IDbCommand cmd = 连接.CreateCommand();
			try
			{
				准备命令(cmd, 连接, (IDbTransaction)null, 命令类型, 命令内容, 命令参数集合, out mustCloseConnection );
				清除参数规则(cmd);

				return 获得XML读取器(cmd);
			}
			catch (Exception ex)
			{	
				if( mustCloseConnection )
					连接.Close();
				// Don't just throw ex.  It changes the call stack.  But we want the ex around for debugging, so...
				Debug.WriteLine(ex);
				throw;
			}
		}

		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a resultset) against the specified IDbConnection 
		/// using the provided parameter values.  This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
		/// </summary>
		/// <remarks>
		/// This method provides no access to output parameters or the stored procedure's return 值 parameter.
		/// </remarks>
		/// <example>
		/// <code>
		/// XmlReader r = helper.获得XML读取器(conn, "GetOrders", 24, 36);
		/// </code></example>
		/// <param name="连接">A valid IDbConnection</param>
		/// <param name="存储过程名称">The name of the stored procedure using "FOR XML AUTO"</param>
		/// <param name="参数值集合">An array of objects to be assigned as the input values of the stored procedure</param>
		/// <returns>An XmlReader containing the resultset generated by the 命令</returns>
		/// <exception cref="System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		public XmlReader 获得XML读取器(IDbConnection 连接, string 存储过程名称, params object[] 参数值集合)
		{
			if( 连接 == null ) throw new ArgumentNullException( "连接" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			// If we receive parameter values, we need to figure out where they go
			if ((参数值集合 != null) && (参数值集合.Length > 0)) 
			{
				// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
				ArrayList tempParameter = new ArrayList();
				foreach( IDataParameter parameter in 获取存储过程参数设置(连接, 存储过程名称) )
				{
					tempParameter.Add( parameter );
				}
				IDataParameter[] commandParameters = (IDataParameter[])tempParameter.ToArray( typeof(IDataParameter) );

				// Assign the provided values to these parameters based on parameter order
				分配参数值集合(commandParameters, 参数值集合);

				// Call the overload that takes an array of IDataParameters
				return 获得XML读取器(连接, CommandType.StoredProcedure, 存储过程名称, commandParameters);
			}
			else 
			{
				// Otherwise we can just call the SP without params
				return 获得XML读取器(连接, CommandType.StoredProcedure, 存储过程名称);
			}
		}

		/// <summary>
		/// Execute an IDbCommand (that returns a resultset and takes no parameters) against the provided IDbTransaction. 
		/// </summary>
		/// <example>
		/// <code>
		/// XmlReader r = helper.获得XML读取器(tran, CommandType.StoredProcedure, "GetOrders");
		/// </code></example>
		/// <param name="事务">A valid IDbTransaction</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令 using "FOR XML AUTO"</param>
		/// <returns>An XmlReader containing the resultset generated by the 命令</returns>
		public XmlReader 获得XML读取器(IDbTransaction 事务, CommandType 命令类型, string 命令内容)
		{
			// Pass through the call providing null for the set of IDataParameters
			return 获得XML读取器(事务, 命令类型, 命令内容, (IDataParameter[])null);
		}

		/// <summary>
		/// Execute an IDbCommand (that returns a resultset) against the specified IDbTransaction
		/// using the provided parameters.
		/// </summary>
		/// <example>
		/// <code>
		/// XmlReader r = helper.获得XML读取器(tran, CommandType.StoredProcedure, "GetOrders", GetParameter("@prodid", 24));
		/// </code></example>
		/// <param name="事务">A valid IDbTransaction</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令 using "FOR XML AUTO"</param>
		/// <param name="命令参数集合">An array of IDataParameters used to execute the 命令</param>
		/// <returns>An XmlReader containing the resultset generated by the 命令</returns>
		/// <exception cref="System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务.Connection is null</exception>
		public XmlReader 获得XML读取器(IDbTransaction 事务, CommandType 命令类型, string 命令内容, params IDataParameter[] 命令参数集合)
		{
			if( 事务 == null ) throw new ArgumentNullException( "事务" );
			if( 事务 != null && 事务.Connection == null ) throw new ArgumentException( "The 事务 was rolled back or commited, please provide an open 事务.", "事务" );

			// Create a 命令 and prepare it for execution
			IDbCommand cmd = 事务.Connection.CreateCommand();
			bool mustCloseConnection = false;
			准备命令(cmd, 事务.Connection, 事务, 命令类型, 命令内容, 命令参数集合, out mustCloseConnection );
			清除参数规则(cmd);

			// Create the DataAdapter & DataSet
			XmlReader retval = 获得XML读取器(cmd);
			
			// Detach the IDataParameters from the 命令 object, so they can be used again
			// don't do this...screws up output params -- cjbreisch
			// 命令.Parameters.Clear();
			return retval;			
		}

		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a resultset) against the specified 
		/// IDbTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
		/// </summary>
		/// <remarks>
		/// This method provides no access to output parameters or the stored procedure's return 值 parameter.
		/// </remarks>
		/// <example>
		/// <code>
		/// XmlReader r = helper.获得XML读取器(trans, "GetOrders", 24, 36);
		/// </code></example>
		/// <param name="事务">A valid IDbTransaction</param>
		/// <param name="存储过程名称">The name of the stored procedure using "FOR XML AUTO"</param>
		/// <param name="参数值集合">An array of objects to be assigned as the input values of the stored procedure</param>
		/// <returns>An XmlReader containing the resultset generated by the 命令</returns>
		/// <exception cref="System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务.Connection is null</exception>
		public XmlReader 获得XML读取器(IDbTransaction 事务, string 存储过程名称, params object[] 参数值集合)
		{
			if( 事务 == null ) throw new ArgumentNullException( "事务" );
			if( 事务 != null && 事务.Connection == null ) throw new ArgumentException( "The 事务 was rolled back or commited, please provide an open 事务.", "事务" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			// If we receive parameter values, we need to figure out where they go
			if ((参数值集合 != null) && (参数值集合.Length > 0)) 
			{
				// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
				ArrayList tempParameter = new ArrayList();
				foreach( IDataParameter parameter in 获取存储过程参数设置(事务.Connection, 存储过程名称) )
				{
					tempParameter.Add( parameter );
				}
				IDataParameter[] commandParameters = (IDataParameter[])tempParameter.ToArray( typeof(IDataParameter) );

				// Assign the provided values to these parameters based on parameter order
				分配参数值集合(commandParameters, 参数值集合);

				// Call the overload that takes an array of IDataParameters
				return 获得XML读取器(事务, CommandType.StoredProcedure, 存储过程名称, commandParameters);
			}
			else 
			{
				// Otherwise we can just call the SP without params
				return 获得XML读取器(事务, CommandType.StoredProcedure, 存储过程名称);
			}
		}

		#endregion 获得XML读取器

		#region 依据参数获得XML读取器
		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a resultset) against the specified IDbConnection 
		/// using the 数据行 column values as the stored procedure's parameters values.
		/// This method will assign the parameter values based on parameter order.
		/// </summary>
		/// <param name="命令">The IDbCommand to execute</param>
		/// <param name="数据行">The 数据行 used to hold the stored procedure's parameter values.</param>
		/// <returns>An XmlReader containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令 is null.</exception>
		public XmlReader 依据参数获得XML读取器(IDbCommand 命令, DataRow 数据行)
		{
			if( 命令 == null ) throw new ArgumentNullException( "命令" );
			
			// If the row has values, the store procedure parameters must be initialized
			if( 数据行 != null && 数据行.ItemArray.Length > 0)
			{
				// Set the parameters values
				分配参数值集合(命令.Parameters, 数据行);
		        
				return 获得XML读取器(命令);
			}
			else
			{
				return 获得XML读取器(命令);
			}
		}
		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a resultset) against the specified IDbConnection 
		/// using the 数据行 column values as the stored procedure's parameters values.
		/// This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
		/// </summary>
		/// <param name="连接">A valid IDbConnection object</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="数据行">The 数据行 used to hold the stored procedure's parameter values.</param>
		/// <returns>An XmlReader containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		public XmlReader 依据参数获得XML读取器(IDbConnection 连接, String 存储过程名称, DataRow 数据行)
		{
			if( 连接 == null ) throw new ArgumentNullException( "连接" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			// If the row has values, the store procedure parameters must be initialized
			if( 数据行 != null && 数据行.ItemArray.Length > 0)
			{
				// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
				ArrayList tempParameter = new ArrayList();
				foreach( IDataParameter parameter in 获取存储过程参数设置(连接, 存储过程名称) )
				{
					tempParameter.Add( parameter );
				}
				IDataParameter[] commandParameters = (IDataParameter[])tempParameter.ToArray( typeof(IDataParameter) );
		        
				// Set the parameters values
				分配参数值集合(commandParameters, 数据行);
		        
				return 获得XML读取器(连接, CommandType.StoredProcedure, 存储过程名称, commandParameters);
			}
			else
			{
				return 获得XML读取器(连接, CommandType.StoredProcedure, 存储过程名称);
			}
		}

		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a resultset) against the specified IDbTransaction 
		/// using the 数据行 column values as the stored procedure's parameters values.
		/// This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
		/// </summary>
		/// <param name="事务">A valid IDbTransaction object</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="数据行">The 数据行 used to hold the stored procedure's parameter values.</param>
		/// <returns>An XmlReader containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务.Connection is null</exception>
		public XmlReader 依据参数获得XML读取器(IDbTransaction 事务, String 存储过程名称, DataRow 数据行)
		{
			if( 事务 == null ) throw new ArgumentNullException( "事务" );
			if( 事务 != null && 事务.Connection == null ) throw new ArgumentException( "The 事务 was rolled back or commited, please provide an open 事务.", "事务" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			// If the row has values, the store procedure parameters must be initialized
			if( 数据行 != null && 数据行.ItemArray.Length > 0)
			{
				// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
				ArrayList tempParameter = new ArrayList();
				foreach( IDataParameter parameter in 获取存储过程参数设置(事务.Connection, 存储过程名称 ) )
				{
					tempParameter.Add( parameter );
				}
				IDataParameter[] commandParameters = (IDataParameter[])tempParameter.ToArray( typeof(IDataParameter) );
		        
				// Set the parameters values
				分配参数值集合(commandParameters, 数据行);
		        
				return 获得XML读取器(事务, CommandType.StoredProcedure, 存储过程名称, commandParameters);
			}
			else
			{
				return 获得XML读取器(事务, CommandType.StoredProcedure, 存储过程名称);
			}
		}
		#endregion

		#region 填充数据集
		/// <summary>
		/// Execute an IDbCommand (that returns a resultset) against the database specified in 
		/// the 连接 string. 
		/// </summary>
		/// <param name="命令">The IDbCommand to execute</param>
		/// <param name="数据集">A DataSet wich will contain the resultset generated by the 命令</param>
		/// <param name="表名称集合">This array will be used to create table mappings allowing the DataTables to be referenced
		/// by a user defined name (probably the actual table name)</param>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令 is null.</exception>
		public virtual void 填充数据集(IDbCommand 命令, DataSet 数据集, string[] 表名称集合)
		{
			bool mustCloseConnection = false;

			// Clean Up Parameter Syntax
			清除参数规则(命令);

			if (命令.Connection.State != ConnectionState.Open)
			{
				命令.Connection.Open();
				mustCloseConnection = true;
			}

			// Create the DataAdapter & DataSet
			IDbDataAdapter dataAdapter = null;
			try
			{
				dataAdapter = 获取数据适配器();
				dataAdapter.SelectCommand = 命令;
			                
				// Add the table mappings specified by the user
				if (表名称集合 != null && 表名称集合.Length > 0)
				{
					string tableName = "Table";
					for (int index=0; index < 表名称集合.Length; index++)
					{
						if( 表名称集合[index] == null || 表名称集合[index].Length == 0 ) 
							throw new ArgumentException( "The 表名称集合 parameter must contain a list of tables, a value was provided as null or empty string.", "表名称集合" );
						dataAdapter.TableMappings.Add( 
							tableName + (index == 0 ? "" : index.ToString()), 
							表名称集合[index] );
					}
				}
                
				// Fill the DataSet using default values for DataTable names, etc
				dataAdapter.Fill(数据集);
				
				if (mustCloseConnection)
				{
					命令.Connection.Close();
				}
				
				// Detach the IDataParameters from the 命令 object, so they can be used again
				// don't do this...screws up output params  --cjb
				// 命令.Parameters.Clear();
			}
			finally
			{
				IDisposable id = dataAdapter as IDisposable;
				if( id != null ) id.Dispose();
			}

		}

		/// <summary>
		/// Execute an IDbCommand (that returns a resultset and takes no parameters) against the database specified in 
		/// the 连接 string. 
		/// </summary>
		/// <example>
		/// <code>
		/// helper.填充数据集(connString, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"});
		/// </code></example>
		/// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <param name="数据集">A DataSet wich will contain the resultset generated by the 命令</param>
		/// <param name="表名称集合">This array will be used to create table mappings allowing the DataTables to be referenced
		/// by a user defined name (probably the actual table name)</param>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接字符串 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		public virtual void 填充数据集(string 连接字符串, CommandType 命令类型, string 命令内容, DataSet 数据集, string[] 表名称集合)
		{
			if( 连接字符串 == null || 连接字符串.Length == 0 ) throw new ArgumentNullException( "连接字符串" );
			if( 数据集 == null ) throw new ArgumentNullException( "数据集" );
            
			// Create & open an IDbConnection, and dispose of it after we are done
			IDbConnection connection = null;
			try
			{
				connection = 获取连接(连接字符串);
				connection.Open();

				// Call the overload that takes a 连接 in place of the 连接 string
				填充数据集(connection, 命令类型, 命令内容, 数据集, 表名称集合);
			}
			finally
			{
				IDisposable id = connection as IDisposable;
				if( id != null ) id.Dispose();
			}
		}

		/// <summary>
		/// Execute an IDbCommand (that returns a resultset) against the database specified in the 连接 string 
		/// using the provided parameters.
		/// </summary>
		/// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <param name="命令参数集合">An array of IDataParameters used to execute the 命令</param>
		/// <param name="数据集">A DataSet wich will contain the resultset generated by the 命令</param>
		/// <param name="表名称集合">This array will be used to create table mappings allowing the DataTables to be referenced
		/// by a user defined name (probably the actual table name)
		/// </param>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接字符串 is null</exception>
		/// <exception cref="System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		public virtual void 填充数据集(string 连接字符串, CommandType 命令类型,
			string 命令内容, DataSet 数据集, string[] 表名称集合,
			params IDataParameter[] 命令参数集合)
		{
			if( 连接字符串 == null || 连接字符串.Length == 0 ) throw new ArgumentNullException( "连接字符串" );
			if( 数据集 == null ) throw new ArgumentNullException( "数据集" );
			// Create & open an IDbConnection, and dispose of it after we are done
			IDbConnection connection = null;
			try
			{
				connection = 获取连接(连接字符串);
				connection.Open();

				// Call the overload that takes a 连接 in place of the 连接 string
				填充数据集(connection, 命令类型, 命令内容, 数据集, 表名称集合, 命令参数集合);
			}
			finally
			{
				IDisposable id = connection as IDisposable;
				if( id != null ) id.Dispose();
			}
		}

		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a resultset) against the database specified in 
		/// the 连接 string using the provided parameter values.  This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
		/// </summary>
		/// <remarks>
		/// This method provides no access to output parameters or the stored procedure's return 值 parameter.
		/// </remarks>
		/// <example>
		/// <code>
		/// helper.填充数据集(connString, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"}, 24);
		/// </code></example>
		/// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="数据集">A dataset wich will contain the resultset generated by the 命令</param>
		/// <param name="表名称集合">This array will be used to create table mappings allowing the DataTables to be referenced
		/// by a user defined name (probably the actual table name)
		/// </param>    
		/// <param name="参数值集合">An array of objects to be assigned as the input values of the stored procedure</param>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接字符串 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		public virtual void 填充数据集(string 连接字符串, string 存储过程名称,
			DataSet 数据集, string[] 表名称集合,
			params object[] 参数值集合)
		{
			if( 连接字符串 == null || 连接字符串.Length == 0 ) throw new ArgumentNullException( "连接字符串" );
			if( 数据集 == null ) throw new ArgumentNullException( "数据集" );
			
			
			// Create & open an IDbConnection, and dispose of it after we are done
			IDbConnection connection = null;
			try
			{
				connection = 获取连接(连接字符串);
				connection.Open();

				// Call the overload that takes a 连接 in place of the 连接 string
				填充数据集 (connection, 存储过程名称, 数据集, 表名称集合, 参数值集合);
			}
			finally
			{
				IDisposable id = connection as IDisposable;
				if( id != null ) id.Dispose();
			}
		}

		/// <summary>
		/// Execute an IDbCommand (that returns a resultset and takes no parameters) against the provided IDbConnection. 
		/// </summary>
		/// <example>
		/// <code>
		/// helper.填充数据集(conn, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"});
		/// </code></example>
		/// <param name="连接">A valid IDbConnection</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <param name="数据集">A dataset wich will contain the resultset generated by the 命令</param>
		/// <param name="表名称集合">This array will be used to create table mappings allowing the DataTables to be referenced
		/// by a user defined name (probably the actual table name)
		/// </param>    
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		public virtual void 填充数据集(IDbConnection 连接, CommandType 命令类型, 
			string 命令内容, DataSet 数据集, string[] 表名称集合)
		{
			填充数据集(连接, 命令类型, 命令内容, 数据集, 表名称集合, null);
		}

		/// <summary>
		/// Execute an IDbCommand (that returns a resultset) against the specified IDbConnection 
		/// using the provided parameters.
		/// </summary>
		/// <param name="连接">A valid IDbConnection</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <param name="数据集">A DataSet wich will contain the resultset generated by the 命令</param>
		/// <param name="表名称集合">This array will be used to create table mappings allowing the DataTables to be referenced
		/// by a user defined name (probably the actual table name)
		/// </param>
		/// <param name="命令参数集合">An array of IDataParameters used to execute the 命令</param>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		public virtual void 填充数据集(IDbConnection 连接, CommandType 命令类型, 
			string 命令内容, DataSet 数据集, string[] 表名称集合,
			params IDataParameter[] 命令参数集合)
		{
			填充数据集(连接, null, 命令类型, 命令内容, 数据集, 表名称集合, 命令参数集合);
		}

		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a resultset) against the specified IDbConnection 
		/// using the provided parameter values.  This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
		/// </summary>
		/// <remarks>
		/// This method provides no access to output parameters or the stored procedure's return 值 parameter.
		/// </remarks>
		/// <example>
		/// <code>
		/// helper.填充数据集(conn, "GetOrders", ds, new string[] {"orders"}, 24, 36);
		/// </code></example>
		/// <param name="连接">A valid IDbConnection</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="数据集">A dataset wich will contain the resultset generated by the 命令</param>
		/// <param name="表名称集合">This array will be used to create table mappings allowing the DataTables to be referenced
		/// by a user defined name (probably the actual table name)
		/// </param>
		/// <param name="参数值集合">An array of objects to be assigned as the input values of the stored procedure</param>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		public virtual void 填充数据集(IDbConnection 连接, string 存储过程名称, 
			DataSet 数据集, string[] 表名称集合,
			params object[] 参数值集合)
		{
			if ( 连接 == null ) throw new ArgumentNullException( "连接" );
			if (数据集 == null ) throw new ArgumentNullException( "数据集" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			// If we receive parameter values, we need to figure out where they go
			if ((参数值集合 != null) && (参数值集合.Length > 0)) 
			{
				IDataParameter[] iDataParameterValues = 获得数据参数(参数值集合.Length);

				// if we've been passed IDataParameters, don't do parameter discovery
				if (验证参数合法性(参数值集合, iDataParameterValues))
				{
					填充数据集(连接, CommandType.StoredProcedure, 存储过程名称, 数据集, 表名称集合, iDataParameterValues);
				}
				else
				{

					// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
					bool includeReturnValue = 检验返回参数值(参数值集合);
					IDataParameter[] commandParameters = 获取存储过程参数设置(连接, 存储过程名称, includeReturnValue);

					// Assign the provided values to these parameters based on parameter order
					分配参数值集合(commandParameters, 参数值集合);

					// Call the overload that takes an array of IDataParameters
					填充数据集(连接, CommandType.StoredProcedure, 存储过程名称, 数据集, 表名称集合, commandParameters);
				}
			}
			else 
			{
				// Otherwise we can just call the SP without params
				填充数据集(连接, CommandType.StoredProcedure, 存储过程名称, 数据集, 表名称集合);
			}    
		}

		/// <summary>
		/// Execute an IDbCommand (that returns a resultset and takes no parameters) against the provided IDbTransaction. 
		/// </summary>
		/// <example>
		/// <code>
		/// helper.填充数据集(tran, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"});
		/// </code></example>
		/// <param name="事务">A valid IDbTransaction</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <param name="数据集">A dataset wich will contain the resultset generated by the 命令</param>
		/// <param name="表名称集合">This array will be used to create table mappings allowing the DataTables to be referenced
		/// by a user defined name (probably the actual table name)
		/// </param>    
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务.Connection is null</exception>
		public virtual void 填充数据集(IDbTransaction 事务, CommandType 命令类型, 
			string 命令内容,
			DataSet 数据集, string[] 表名称集合)
		{
			填充数据集 (事务, 命令类型, 命令内容, 数据集, 表名称集合, null);    
		}

		/// <summary>
		/// Execute an IDbCommand (that returns a resultset) against the specified IDbTransaction
		/// using the provided parameters.
		/// </summary>
		/// <param name="事务">A valid IDbTransaction</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <param name="数据集">A DataSet wich will contain the resultset generated by the 命令</param>
		/// <param name="表名称集合">This array will be used to create table mappings allowing the DataTables to be referenced
		/// by a user defined name (probably the actual table name)
		/// </param>
		/// <param name="命令参数集合">An array of IDataParameters used to execute the 命令</param>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务.Connection is null</exception>
		public virtual void 填充数据集(IDbTransaction 事务, CommandType 命令类型, 
			string 命令内容, DataSet 数据集, string[] 表名称集合,
			params IDataParameter[] 命令参数集合)
		{
			填充数据集(事务.Connection, 事务, 命令类型, 命令内容, 数据集, 表名称集合, 命令参数集合);
		}

		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a resultset) against the specified 
		/// IDbTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
		/// </summary>
		/// <remarks>
		/// This method provides no access to output parameters or the stored procedure's return 值 parameter.
		/// </remarks>
		/// <example>
		/// <code>
		/// helper.填充数据集(tran, "GetOrders", ds, new string[] {"orders"}, 24, 36);
		/// </code></example>
		/// <param name="事务">A valid IDbTransaction</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="数据集">A dataset wich will contain the resultset generated by the 命令</param>
		/// <param name="表名称集合">This array will be used to create table mappings allowing the DataTables to be referenced
		/// by a user defined name (probably the actual table name)
		/// </param>
		/// <param name="参数值集合">An array of objects to be assigned as the input values of the stored procedure</param>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务.Connection is null</exception>
		public virtual void 填充数据集(IDbTransaction 事务, string 存储过程名称,
			DataSet 数据集, string[] 表名称集合,
			params object[] 参数值集合) 
		{
			if( 事务 == null ) throw new ArgumentNullException( "事务" );
			if( 事务 != null && 事务.Connection == null ) throw new ArgumentException( "The 事务 was rolled back or commited, please provide an open 事务.", "事务" );
			if( 数据集 == null ) throw new ArgumentNullException( "数据集" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			// If we receive parameter values, we need to figure out where they go
			if ((参数值集合 != null) && (参数值集合.Length > 0)) 
			{
				IDataParameter[] iDataParameterValues = 获得数据参数(参数值集合.Length);

				// if we've been passed IDataParameters, don't do parameter discovery
				if (验证参数合法性(参数值集合, iDataParameterValues))
				{
					填充数据集(事务, CommandType.StoredProcedure, 存储过程名称, 数据集, 表名称集合, iDataParameterValues);
				}
				else
				{
					// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
					bool includeReturnValue = 检验返回参数值(参数值集合);
					IDataParameter[] commandParameters = 获取存储过程参数设置(事务.Connection, 存储过程名称, includeReturnValue);

					// Assign the provided values to these parameters based on parameter order
					分配参数值集合(commandParameters, 参数值集合);

					// Call the overload that takes an array of IDataParameters
					填充数据集(事务, CommandType.StoredProcedure, 存储过程名称, 数据集, 表名称集合, commandParameters);
				}
			}
			else 
			{
				// Otherwise we can just call the SP without params
				填充数据集(事务, CommandType.StoredProcedure, 存储过程名称, 数据集, 表名称集合);
			}    
		}

		/// <summary>
		/// Private helper method that execute an IDbCommand (that returns a resultset) against the specified IDbTransaction and IDbConnection
		/// using the provided parameters.
		/// </summary>
		/// <param name="连接">A valid IDbConnection</param>
		/// <param name="事务">A valid IDbTransaction</param>
		/// <param name="命令类型">The CommandType (stored procedure, text, etc.)</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <param name="数据集">A DataSet wich will contain the resultset generated by the 命令</param>
		/// <param name="表名称集合">This array will be used to create table mappings allowing the DataTables to be referenced
		/// by a user defined name (probably the actual table name)
		/// </param>
		/// <param name="命令参数集合">An array of IDataParameters used to execute the 命令</param>
		private void 填充数据集(IDbConnection 连接, IDbTransaction 事务, CommandType 命令类型, 
			string 命令内容, DataSet 数据集, string[] 表名称集合,
			params IDataParameter[] 命令参数集合)
		{
			if( 连接 == null ) throw new ArgumentNullException( "连接" );
			if( 数据集 == null ) throw new ArgumentNullException( "数据集" );

			// Create a 命令 and prepare it for execution
			IDbCommand command = 连接.CreateCommand();
			bool mustCloseConnection = false;
			准备命令(command, 连接, 事务, 命令类型, 命令内容, 命令参数集合, out mustCloseConnection );
			清除参数规则(command);

			填充数据集(command, 数据集, 表名称集合);

			if( mustCloseConnection )
				连接.Close();
		}
		#endregion

        #region 更新数据集
        /// <summary>
		/// This method consumes the RowUpdatingEvent and passes it on to the consumer specifed in the call to 更新数据集
		/// </summary>
		/// <param name="obj">The object that generated the event</param>
		/// <param name="e">The System.Data.Common.RowUpdatingEventArgs</param>
		protected void 更新行(object obj, System.Data.Common.RowUpdatingEventArgs e)
		{
			if (this.m_rowUpdating != null)
				m_rowUpdating(obj,e);
		}
		
		/// <summary>
		/// This method consumes the RowUpdatedEvent and passes it on to the consumer specifed in the call to 更新数据集
		/// </summary>
		/// <param name="obj">The object that generated the event</param>
		/// <param name="e">The System.Data.Common.RowUpdatingEventArgs</param>
		protected void 更新行完毕(object obj, System.Data.Common.RowUpdatedEventArgs e)
		{
			if (this.m_rowUpdated != null)
				m_rowUpdated(obj,e);
		}

		/// <summary>
		/// Set up a 命令 for updating a DataSet.
		/// </summary>
		/// <param name="命令">命令 object to prepare</param>
		/// <param name="需要关闭连接">output parameter specifying whether the 连接 used should be closed by the DAAB</param>
		/// <returns>An IDbCommand object</returns>
		protected virtual IDbCommand 设置命令(IDbCommand 命令, out bool 需要关闭连接 )
		{
			需要关闭连接 = false;
			if (命令 != null)
			{
				IDataParameter[] commandParameters = new IDataParameter[ 命令.Parameters.Count ];
				命令.Parameters.CopyTo( commandParameters, 0 );
				命令.Parameters.Clear();
				this.准备命令( 命令, 命令.Connection, null, 命令.CommandType, 命令.CommandText, commandParameters, out 需要关闭连接 );
				清除参数规则(命令);
			}
			
			return 命令;
		}
		
		/// <summary>
		/// Executes the respective 命令 for each inserted, updated, or deleted row in the DataSet.
		/// </summary>
		/// <example>
		/// <code>
		/// helper.更新数据集(conn, 插入命令, 删除命令, 更新命令, 数据集, "Order");
		/// </code></example>
		/// <param name="插入命令">A valid SQL statement or stored procedure to insert new records into the data source</param>
		/// <param name="删除命令">A valid SQL statement or stored procedure to delete records from the data source</param>
		/// <param name="更新命令">A valid SQL statement or stored procedure used to update records in the data source</param>
		/// <param name="数据集">The DataSet used to update the data source</param>
		/// <param name="表名称">The DataTable used to update the data source.</param>
		public virtual void 更新数据集(IDbCommand 插入命令, IDbCommand 删除命令, IDbCommand 更新命令, DataSet 数据集, string 表名称)
		{
			更新数据集(插入命令, 删除命令, 更新命令, 数据集, 表名称, null, null);
		}

		/// <summary> 
		/// Executes the IDbCommand for each inserted, updated, or deleted row in the DataSet also implementing 更新行 and 更新行完毕 Event Handlers 
		/// </summary> 
		/// <example> 
		/// <code>
		/// RowUpdatingEventHandler 更新行处理器 = new RowUpdatingEventHandler( OnRowUpdating ); 
		/// RowUpdatedEventHandler 更新行完毕处理器 = new RowUpdatedEventHandler( OnRowUpdated ); 
		/// helper.UpdateDataSet(sqlInsertCommand, sqlDeleteCommand, sqlUpdateCommand, 数据集, "Order", 更新行处理器, 更新行完毕处理器); 
		/// </code></example> 
		/// <param name="插入命令">A valid SQL statement or stored procedure to insert new records into the data source</param> 
		/// <param name="删除命令">A valid SQL statement or stored procedure to delete records from the data source</param> 
		/// <param name="更新命令">A valid SQL statement or stored procedure used to update records in the data source</param> 
		/// <param name="数据集">The DataSet used to update the data source</param> 
		/// <param name="表名称">The DataTable used to update the data source.</param> 
		/// <param name="更新行处理器">RowUpdatingEventHandler</param> 
		/// <param name="更新行完毕处理器">RowUpdatedEventHandler</param> 
		public void 更新数据集(IDbCommand 插入命令, IDbCommand 删除命令, IDbCommand 更新命令,
            DataSet 数据集, string 表名称, 更新行处理器 更新行处理器, 更新行完毕处理器 更新行完毕处理器) 
		{
			int rowsAffected = 0;

			if( 表名称 == null || 表名称.Length == 0 ) throw new ArgumentNullException( "表名称" ); 

			// Create an IDbDataAdapter, and dispose of it after we are done
			IDbDataAdapter dataAdapter = null;
			try
			{
				bool mustCloseUpdateConnection = false;
				bool mustCloseInsertConnection = false;
				bool mustCloseDeleteConnection = false;

				dataAdapter = 获取数据适配器();
                
				// Set the data adapter commands
				dataAdapter.UpdateCommand = 设置命令(更新命令, out mustCloseUpdateConnection);
				dataAdapter.InsertCommand = 设置命令(插入命令, out mustCloseInsertConnection);
				dataAdapter.DeleteCommand = 设置命令(删除命令, out mustCloseDeleteConnection);

				添加更新事件处理器(dataAdapter, 更新行处理器, 更新行完毕处理器);
				
				if( dataAdapter is DbDataAdapter ) 
				{
					// Update the DataSet changes in the data source
					try
					{
						rowsAffected = ((DbDataAdapter)dataAdapter).Update(数据集, 表名称);
					} 
					catch (Exception ex) 
					{
						// Don't just throw ex.  It changes the call stack.  But we want the ex around for debugging, so...
						Debug.WriteLine(ex);
						throw;
					}
				}
				else
				{
					dataAdapter.TableMappings.Add(表名称, "Table"); 
	
					// Update the DataSet changes in the data source
					rowsAffected = dataAdapter.Update (数据集); 
				}

				// Commit all the changes made to the DataSet
				数据集.Tables[表名称].AcceptChanges();

				if (mustCloseUpdateConnection)
				{
					更新命令.Connection.Close();
				}
				if (mustCloseInsertConnection)
				{
					插入命令.Connection.Close();
				}
				if (mustCloseDeleteConnection)
				{
					删除命令.Connection.Close();
				}
			}
			finally
			{
				IDisposable id = dataAdapter as IDisposable;
				if( id != null ) id.Dispose();
			}
		}
		#endregion

		#region 创建命令
		/// <summary>
		/// Simplify the creation of an IDbCommand object by allowing
		/// a stored procedure and optional parameters to be provided
		/// </summary>
		/// <example>
		/// <code>
		/// IDbCommand 命令 = helper.创建命令(conn, "AddCustomer", "CustomerID", "CustomerName");
		/// </code></example>
		/// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="源列集合">An array of string to be assigned as the source columns of the stored procedure parameters</param>
		/// <returns>A valid IDbCommand object</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接字符串 is null</exception>
		/// <exception cref="System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
		public virtual IDbCommand 创建命令(string 连接字符串, string 存储过程名称, params string[] 源列集合) 
		{
			return 创建命令(this.获取连接(连接字符串), 存储过程名称, 源列集合);
		}
		/// <summary>
		/// Simplify the creation of an IDbCommand object by allowing
		/// a stored procedure and optional parameters to be provided
		/// </summary>
		/// <example>
		/// <code>
		/// IDbCommand 命令 = helper.创建命令(conn, "AddCustomer", "CustomerID", "CustomerName");
		/// </code></example>
		/// <param name="连接">A valid IDbConnection object</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="源列集合">An array of string to be assigned as the source columns of the stored procedure parameters</param>
		/// <returns>A valid IDbCommand object</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		public virtual IDbCommand 创建命令(IDbConnection 连接, string 存储过程名称, params string[] 源列集合) 
		{
			if( 连接 == null ) throw new ArgumentNullException( "连接" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			// Create an IDbCommand
			IDbCommand cmd = 连接.CreateCommand();
			cmd.CommandText = 存储过程名称;
			cmd.CommandType = CommandType.StoredProcedure;

			// If we receive parameter values, we need to figure out where they go
			if ((源列集合 != null) && (源列集合.Length > 0)) 
			{
				// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
				IDataParameter[] commandParameters = 获取存储过程参数设置(连接, 存储过程名称);

				// Assign the provided source columns to these parameters based on parameter order
				for (int index=0; index < 源列集合.Length; index++)
					if (commandParameters[index].SourceColumn == String.Empty)
						commandParameters[index].SourceColumn = 源列集合[index];

				// Attach the discovered parameters to the IDbCommand object
				附加参数 (cmd, commandParameters);
			}

			return cmd;
		}

		/// <summary>
		/// Simplify the creation of an IDbCommand object by allowing
		/// a stored procedure and optional parameters to be provided
		/// </summary>
		/// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
		/// <param name="命令内容">A valid SQL statement</param>
		/// <param name="命令类型">A System.Data.CommandType</param>
		/// <param name="命令参数集合">The parameters for the SQL statement</param>
		/// <returns>A valid IDbCommand object</returns>
		public virtual IDbCommand 创建命令(string 连接字符串, string 命令内容, CommandType 命令类型, params IDataParameter[] 命令参数集合) 
		{
			return 创建命令(this.获取连接(连接字符串), 命令内容, 命令类型, 命令参数集合);
		}
		/// <summary>
		/// Simplify the creation of an IDbCommand object by allowing
		/// a stored procedure and optional parameters to be provided
		/// </summary>
		/// <example><code>
		/// IDbCommand 命令 = helper.创建命令(conn, "AddCustomer", "CustomerID", "CustomerName");
		/// </code></example>
		/// <param name="连接">A valid IDbConnection object</param>
		/// <param name="命令内容">A valid SQL statement</param>
		/// <param name="命令类型">A System.Data.CommandType</param>
		/// <param name="命令参数集合">The parameters for the SQL statement</param>
		/// <returns>A valid IDbCommand object</returns>
		public virtual IDbCommand 创建命令(IDbConnection 连接, string 命令内容, CommandType 命令类型, params IDataParameter[] 命令参数集合) 
		{
			if( 连接 == null ) throw new ArgumentNullException( "连接" );
			if( 命令内容 == null || 命令内容.Length == 0 ) throw new ArgumentNullException( "命令内容" );

			// Create an IDbCommand
			IDbCommand cmd = 连接.CreateCommand();
			cmd.CommandText = 命令内容;
			cmd.CommandType = 命令类型;

			// If we receive parameter values, we need to figure out where they go
			if ((命令参数集合 != null) && (命令参数集合.Length > 0)) 
			{
				// Assign the provided source columns to these parameters based on parameter order
				for (int index=0; index < 命令参数集合.Length; index++)
					命令参数集合[index].SourceColumn = 命令参数集合[index].ParameterName.TrimStart(new char[] {'@'});
				
				// Attach the discovered parameters to the IDbCommand object
				附加参数 (cmd, 命令参数集合);
			}

			return cmd;
		}
		#endregion

		#region 依据参数执行非查询命令
		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns no resultset) 
		/// against the database specified in the 连接 string using the 
		/// 数据行 column values as the stored procedure's parameters values.
		/// This method will assign the parameter values based on row values.
		/// </summary>
		/// <param name="命令">The IDbCommand to execute</param>
		/// <param name="数据行">The 数据行 used to hold the stored procedure's parameter values.</param>
		/// <returns>An int representing the number of rows affected by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令 is null.</exception>
		public virtual int 依据参数执行非查询命令(IDbCommand 命令, DataRow 数据行)
		{
			int retVal = 0;

			// Clean Up Parameter Syntax
			清除参数规则(命令);

			// If the row has values, the store procedure parameters must be initialized
			if( 数据行 != null && 数据行.ItemArray.Length > 0)
			{
				// Set the parameters values
				分配参数值集合(命令.Parameters, 数据行);
		        
				retVal =  执行非查询命令(命令);
			}
			else
			{
				retVal =  执行非查询命令(命令);
			}
			
			return retVal;
		}

		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns no resultset) against the database specified in 
		/// the 连接 string using the 数据行 column values as the stored procedure's parameters values.
		/// This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on row values.
		/// </summary>
		/// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="数据行">The 数据行 used to hold the stored procedure's parameter values.</param>
		/// <returns>An int representing the number of rows affected by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接字符串 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		public virtual int 依据参数执行非查询命令(String 连接字符串, String 存储过程名称, DataRow 数据行)
		{
			if( 连接字符串 == null || 连接字符串.Length == 0 ) throw new ArgumentNullException( "连接字符串" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );
			
			// If the row has values, the store procedure parameters must be initialized
			if (数据行 != null && 数据行.ItemArray.Length > 0)
			{
				// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
				IDataParameter[] commandParameters = 获取存储过程参数设置(连接字符串, 存储过程名称);
                
				// Set the parameters values
				分配参数值集合(commandParameters, 数据行);
                                
				return 执行非查询命令(连接字符串, CommandType.StoredProcedure, 存储过程名称, commandParameters);
			}
			else
			{
				return 执行非查询命令(连接字符串, CommandType.StoredProcedure, 存储过程名称);
			}
		}

		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns no resultset) against the specified IDbConnection 
		/// using the 数据行 column values as the stored procedure's parameters values.  
		/// This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on row values.
		/// </summary>
		/// <param name="连接">A valid IDbConnection object</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="数据行">The 数据行 used to hold the stored procedure's parameter values.</param>
		/// <returns>An int representing the number of rows affected by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		public virtual int 依据参数执行非查询命令(IDbConnection 连接, String 存储过程名称, DataRow 数据行)
		{
			if( 连接 == null ) throw new ArgumentNullException( "连接" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			// If the row has values, the store procedure parameters must be initialized
			if (数据行 != null && 数据行.ItemArray.Length > 0)
			{
				// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
				IDataParameter[] commandParameters = 获取存储过程参数设置(连接, 存储过程名称);
                
				// Set the parameters values
				分配参数值集合(commandParameters, 数据行);
                                
				return 执行非查询命令(连接, CommandType.StoredProcedure, 存储过程名称, commandParameters);
			}
			else
			{
				return 执行非查询命令(连接, CommandType.StoredProcedure, 存储过程名称);
			}
		}

		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns no resultset) against the specified
		/// IDbTransaction using the 数据行 column values as the stored procedure's parameters values.
		/// This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on row values.
		/// </summary>
		/// <param name="事务">A valid IDbTransaction object</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="数据行">The 数据行 used to hold the stored procedure's parameter values.</param>
		/// <returns>An int representing the number of rows affected by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务.Connection is null</exception>
		public virtual int 依据参数执行非查询命令(IDbTransaction 事务, String 存储过程名称, DataRow 数据行)
		{
			if( 事务 == null ) throw new ArgumentNullException( "事务" );
			if( 事务 != null && 事务.Connection == null ) throw new ArgumentException( "The 事务 was rolled back or commited, please provide an open 事务.", "事务" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			// Sf the row has values, the store procedure parameters must be initialized
			if (数据行 != null && 数据行.ItemArray.Length > 0)
			{
				// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
				IDataParameter[] commandParameters = 获取存储过程参数设置(事务.Connection, 存储过程名称);
                
				// Set the parameters values
				分配参数值集合(commandParameters, 数据行);
                                
				return 执行非查询命令(事务, CommandType.StoredProcedure, 存储过程名称, commandParameters);
			}
			else
			{
				return 执行非查询命令(事务, CommandType.StoredProcedure, 存储过程名称);
			}
		}
		#endregion

		#region 依据参数获得数据集
		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a resultset) against the database specified in 
		/// the 连接 string using the 数据行 column values as the stored procedure's parameters values.
		/// This method will assign the paraemter values based on row values.
		/// </summary>
		/// <param name="命令">The IDbCommand to execute</param>
		/// <param name="数据行">The 数据行 used to hold the stored procedure's parameter values.</param>
		/// <returns>A DataSet containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令 is null.</exception>
		public virtual DataSet 依据参数获得数据集(IDbCommand 命令, DataRow 数据行)
		{
			DataSet ds = null;

			// Clean Up Parameter Syntax
			清除参数规则(命令);

			// If the row has values, the store procedure parameters must be initialized
			if( 数据行 != null && 数据行.ItemArray.Length > 0)
			{
				// Set the parameters values
				分配参数值集合(命令.Parameters, 数据行);
				
		        
				ds =  获得数据集(命令);
			}
			else
			{
				ds =  获得数据集(命令);
			}
			
			return ds;
		}
		
		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a resultset) against the database specified in 
		/// the 连接 string using the 数据行 column values as the stored procedure's parameters values.
		/// This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on row values.
		/// </summary>
		/// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="数据行">The 数据行 used to hold the stored procedure's parameter values.</param>
		/// <returns>A DataSet containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接字符串 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		public virtual DataSet 依据参数获得数据集(string 连接字符串, String 存储过程名称, DataRow 数据行)
		{
			if( 连接字符串 == null || 连接字符串.Length == 0 ) throw new ArgumentNullException( "连接字符串" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			//If the row has values, the store procedure parameters must be initialized
			if ( 数据行 != null && 数据行.ItemArray.Length > 0)
			{
				// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
				IDataParameter[] commandParameters = 获取存储过程参数设置(连接字符串, 存储过程名称);
                
				// Set the parameters values
				分配参数值集合(commandParameters, 数据行);
                
				return 获得数据集(连接字符串, CommandType.StoredProcedure, 存储过程名称, commandParameters);
			}
			else
			{
				return 获得数据集(连接字符串, CommandType.StoredProcedure, 存储过程名称);
			}
		}

		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a resultset) against the specified IDbConnection 
		/// using the 数据行 column values as the store procedure's parameters values.
		/// This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on row values.
		/// </summary>
		/// <param name="连接">A valid IDbConnection object</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="数据行">The 数据行 used to hold the stored procedure's parameter values.</param>
		/// <returns>A DataSet containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		public virtual DataSet 依据参数获得数据集(IDbConnection 连接, String 存储过程名称, DataRow 数据行)
		{
			if( 连接 == null ) throw new ArgumentNullException( "连接" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			// If the row has values, the store procedure parameters must be initialized
			if( 数据行 != null && 数据行.ItemArray.Length > 0)
			{
				// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
				IDataParameter[] commandParameters = 获取存储过程参数设置(连接, 存储过程名称);
                
				// Set the parameters values
				分配参数值集合(commandParameters, 数据行);
                
				return 获得数据集(连接, CommandType.StoredProcedure, 存储过程名称, commandParameters);
			}
			else
			{
				return 获得数据集(连接, CommandType.StoredProcedure, 存储过程名称);
			}
		}

		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a resultset) against the specified IDbTransaction 
		/// using the 数据行 column values as the stored procedure's parameters values.
		/// This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on row values.
		/// </summary>
		/// <param name="事务">A valid IDbTransaction object</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="数据行">The 数据行 used to hold the stored procedure's parameter values.</param>
		/// <returns>A DataSet containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务.Connection is null</exception>
		public virtual DataSet 依据参数获得数据集(IDbTransaction 事务, String 存储过程名称, DataRow 数据行)
		{
			if( 事务 == null ) throw new ArgumentNullException( "事务" );
			if( 事务 != null && 事务.Connection == null ) throw new ArgumentException( "The 事务 was rolled back or commited, please provide an open 事务.", "事务" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			// If the row has values, the store procedure parameters must be initialized
			if( 数据行 != null && 数据行.ItemArray.Length > 0)
			{
				// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
				IDataParameter[] commandParameters = 获取存储过程参数设置(事务.Connection, 存储过程名称);
                
				// Set the parameters values
				分配参数值集合(commandParameters, 数据行);
                
				return 获得数据集(事务, CommandType.StoredProcedure, 存储过程名称, commandParameters);
			}
			else
			{
				return 获得数据集(事务, CommandType.StoredProcedure, 存储过程名称);
			}
		}

		#endregion

		#region 依据参数获得读取器
		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a resultset) against the database specified in 
		/// the 连接 string using the 数据行 column values as the stored procedure's parameters values.
		/// This method will assign the parameter values based on parameter order.
		/// </summary>
		/// <param name="命令">The IDbCommand to execute</param>
		/// <param name="数据行">The 数据行 used to hold the stored procedure's parameter values.</param>
		/// <returns>A IDataReader containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令 is null.</exception>
		public virtual IDataReader 依据参数获得读取器(IDbCommand 命令, DataRow 数据行)
		{
			IDataReader reader = null;

			// Clean Up Parameter Syntax
			清除参数规则(命令);

			// If the row has values, the store procedure parameters must be initialized
			if( 数据行 != null && 数据行.ItemArray.Length > 0)
			{
				// Set the parameters values
				分配参数值集合(命令.Parameters, 数据行);
		        
				reader =  获得读取器(命令);
			}
			else
			{
				reader =  获得读取器(命令);
			}
			
			return reader;
		}
		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a resultset) against the database specified in 
		/// the 连接 string using the 数据行 column values as the stored procedure's parameters values.
		/// This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
		/// </summary>
		/// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="数据行">The 数据行 used to hold the stored procedure's parameter values.</param>
		/// <returns>A IDataReader containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接字符串 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		public virtual IDataReader 依据参数获得读取器(String 连接字符串, String 存储过程名称, DataRow 数据行)
		{
			if( 连接字符串 == null || 连接字符串.Length == 0 ) throw new ArgumentNullException( "连接字符串" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );
			
			// If the row has values, the store procedure parameters must be initialized
			if ( 数据行 != null && 数据行.ItemArray.Length > 0 )
			{
				// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
				IDataParameter[] commandParameters = 获取存储过程参数设置(连接字符串, 存储过程名称);
                
				// Set the parameters values
				分配参数值集合(commandParameters, 数据行);
                
				return 获得读取器(连接字符串, CommandType.StoredProcedure, 存储过程名称, commandParameters);
			}
			else
			{
				return 获得读取器(连接字符串, CommandType.StoredProcedure, 存储过程名称);
			}
		}

                
		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a resultset) against the specified IDbConnection 
		/// using the 数据行 column values as the stored procedure's parameters values.
		/// This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
		/// </summary>
		/// <param name="连接">A valid IDbConnection object</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="数据行">The 数据行 used to hold the stored procedure's parameter values.</param>
		/// <returns>A IDataReader containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		public virtual IDataReader 依据参数获得读取器(IDbConnection 连接, String 存储过程名称, DataRow 数据行)
		{
			if( 连接 == null ) throw new ArgumentNullException( "连接" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			// If the row has values, the store procedure parameters must be initialized
			if( 数据行 != null && 数据行.ItemArray.Length > 0)
			{
				// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
				IDataParameter[] commandParameters = 获取存储过程参数设置(连接, 存储过程名称);
                
				// Set the parameters values
				分配参数值集合(commandParameters, 数据行);
                
				return 获得读取器(连接, CommandType.StoredProcedure, 存储过程名称, commandParameters);
			}
			else
			{
				return 获得读取器(连接, CommandType.StoredProcedure, 存储过程名称);
			}
		}
        
		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a resultset) against the specified IDbTransaction 
		/// using the 数据行 column values as the stored procedure's parameters values.
		/// This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
		/// </summary>
		/// <param name="事务">A valid IDbTransaction object</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="数据行">The 数据行 used to hold the stored procedure's parameter values.</param>
		/// <returns>A IDataReader containing the resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务.Connection is null</exception>
		public virtual IDataReader 依据参数获得读取器(IDbTransaction 事务, String 存储过程名称, DataRow 数据行)
		{
			if( 事务 == null ) throw new ArgumentNullException( "事务" );
			if( 事务 != null && 事务.Connection == null ) throw new ArgumentException( "The 事务 was rolled back or commited, please provide an open 事务.", "事务" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			// If the row has values, the store procedure parameters must be initialized
			if( 数据行 != null && 数据行.ItemArray.Length > 0 )
			{
				// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
				IDataParameter[] commandParameters = 获取存储过程参数设置(事务.Connection, 存储过程名称);
                
				// Set the parameters values
				分配参数值集合(commandParameters, 数据行);
                
				return 获得读取器(事务, CommandType.StoredProcedure, 存储过程名称, commandParameters);
			}
			else
			{
				return 获得读取器(事务, CommandType.StoredProcedure, 存储过程名称);
			}
		}
		#endregion

		#region 依据参数执行单值查询
		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a 1x1 resultset) against the database specified in 
		/// the 连接 string using the 数据行 column values as the stored procedure's parameters values.
		/// This method will assign the parameter values based on parameter order.
		/// </summary>
		/// <param name="命令">The IDbCommand to execute</param>
		/// <param name="数据行">The 数据行 used to hold the stored procedure's parameter values.</param>
		/// <returns>An object containing the 值 in the 1x1 resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令 is null.</exception>
		public virtual object 依据参数执行单值查询(IDbCommand 命令, DataRow 数据行)
		{
			object retVal = null;

			// Clean Up Parameter Syntax
			清除参数规则(命令);

			// If the row has values, the store procedure parameters must be initialized
			if( 数据行 != null && 数据行.ItemArray.Length > 0)
			{
				// Set the parameters values
				分配参数值集合(命令.Parameters, 数据行);
		        
				retVal =  执行单值查询(命令);
			}
			else
			{
				retVal =  执行单值查询(命令);
			}

			return retVal;
		}
		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a 1x1 resultset) against the database specified in 
		/// the 连接 string using the 数据行 column values as the stored procedure's parameters values.
		/// This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
		/// </summary>
		/// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="数据行">The 数据行 used to hold the stored procedure's parameter values.</param>
		/// <returns>An object containing the 值 in the 1x1 resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接字符串 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		public virtual object 依据参数执行单值查询(String 连接字符串, String 存储过程名称, DataRow 数据行)
		{
			if( 连接字符串 == null || 连接字符串.Length == 0 ) throw new ArgumentNullException( "连接字符串" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );
			
			// If the row has values, the store procedure parameters must be initialized
			if( 数据行 != null && 数据行.ItemArray.Length > 0)
			{
				// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
				IDataParameter[] commandParameters = 获取存储过程参数设置(连接字符串, 存储过程名称);
                
				// Set the parameters values
				分配参数值集合(commandParameters, 数据行);
                
				return 执行单值查询(连接字符串, CommandType.StoredProcedure, 存储过程名称, commandParameters);
			}
			else
			{
				return 执行单值查询(连接字符串, CommandType.StoredProcedure, 存储过程名称);
			}
		}

		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a 1x1 resultset) against the specified IDbConnection 
		/// using the 数据行 column values as the stored procedure's parameters values.
		/// This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
		/// </summary>
		/// <param name="连接">A valid IDbConnection object</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="数据行">The 数据行 used to hold the stored procedure's parameter values.</param>
		/// <returns>An object containing the 值 in the 1x1 resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		public virtual object 依据参数执行单值查询(IDbConnection 连接, String 存储过程名称, DataRow 数据行)
		{
			if( 连接 == null ) throw new ArgumentNullException( "连接" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			// If the row has values, the store procedure parameters must be initialized
			if( 数据行 != null && 数据行.ItemArray.Length > 0)
			{
				// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
				IDataParameter[] commandParameters = 获取存储过程参数设置(连接, 存储过程名称);
                
				// Set the parameters values
				分配参数值集合(commandParameters, 数据行);
                
				return 执行单值查询(连接, CommandType.StoredProcedure, 存储过程名称, commandParameters);
			}
			else
			{
				return 执行单值查询(连接, CommandType.StoredProcedure, 存储过程名称);
			}
		}

		/// <summary>
		/// Execute a stored procedure via an IDbCommand (that returns a 1x1 resultset) against the specified IDbTransaction
		/// using the 数据行 column values as the stored procedure's parameters values.
		/// This method will query the database to discover the parameters for the 
		/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
		/// </summary>
		/// <param name="事务">A valid IDbTransaction object</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="数据行">The 数据行 used to hold the stored procedure's parameter values.</param>
		/// <returns>An object containing the 值 in the 1x1 resultset generated by the 命令</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 事务.Connection is null</exception>
		public virtual object 依据参数执行单值查询(IDbTransaction 事务, String 存储过程名称, DataRow 数据行)
		{
			if( 事务 == null ) throw new ArgumentNullException( "事务" );
			if( 事务 != null && 事务.Connection == null ) throw new ArgumentException( "The 事务 was rolled back or commited, please provide an open 事务.", "事务" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			// If the row has values, the store procedure parameters must be initialized
			if( 数据行 != null && 数据行.ItemArray.Length > 0)
			{
				// Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
				IDataParameter[] commandParameters = 获取存储过程参数设置(事务.Connection, 存储过程名称);
                
				// Set the parameters values
				分配参数值集合(commandParameters, 数据行);
                
				return 执行单值查询(事务, CommandType.StoredProcedure, 存储过程名称, commandParameters);
			}
			else
			{
				return 执行单值查询(事务, CommandType.StoredProcedure, 存储过程名称);
			}
		}
		#endregion

        #region 参数识别函数

        /// <summary>
		/// Checks for the existence of a return 值 parameter in the parametervalues
		/// </summary>
		/// <param name="参数值集合">An array of objects to be assigned as the input values of the stored procedure</param>
		/// <returns>true if the 参数值集合 contains a return 值 parameter, false otherwise</returns>
		private bool 检验返回参数值(object[] 参数值集合)
		{
			bool hasReturnValue = false;
			foreach (object paramObject in 参数值集合)
			{
				if (paramObject is IDataParameter)
				{
					IDataParameter paramInstance = (IDataParameter)paramObject;
					if (paramInstance.Direction == ParameterDirection.ReturnValue) 
					{
						hasReturnValue = true;
						break;
					}
				}
			}
			return hasReturnValue;
		}

		/// <summary>
		/// Check to see if the parameter values passed to the helper are, in fact, IDataParameters.
		/// </summary>
		/// <param name="参数值集合">Array of parameter values passed to helper</param>
		/// <param name="通用接口参数值集合">new array of IDataParameters built from parameter values</param>
		/// <returns>True if the parameter values are IDataParameters</returns>
		private bool 验证参数合法性(object[] 参数值集合, IDataParameter[] 通用接口参数值集合)
		{
			bool areIDataParameters = true;
			
			for (int i = 0; i < 参数值集合.Length; i++)
			{
				if (!(参数值集合[i] is IDataParameter))
				{
					areIDataParameters = false;
					break;
				}
				通用接口参数值集合[i] = (IDataParameter)参数值集合[i];
			}
			return areIDataParameters;
		}


		/// <summary>
		/// Retrieves the set of IDataParameters appropriate for the stored procedure
		/// </summary>
		/// <remarks>
		/// This method will query the database for this information, and then store it in a cache for future requests.
		/// </remarks>
		/// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <returns>An array of IDataParameterParameters</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接字符串 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		public virtual IDataParameter[] 获取存储过程参数设置(string 连接字符串, string 存储过程名称)
		{
			return 获取存储过程参数设置(连接字符串, 存储过程名称, false);
		}

		/// <summary>
		/// Retrieves the set of IDataParameters appropriate for the stored procedure
		/// </summary>
		/// <remarks>
		/// This method will query the database for this information, and then store it in a cache for future requests.
		/// </remarks>
		/// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="返回值包含参数值">A bool 值 indicating whether the return 值 parameter should be included in the results</param>
		/// <returns>An array of IDataParameters</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接字符串 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		public virtual IDataParameter[] 获取存储过程参数设置(string 连接字符串, string 存储过程名称, bool 返回值包含参数值)
		{
			if( 连接字符串 == null || 连接字符串.Length == 0 ) throw new ArgumentNullException( "连接字符串" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			using(IDbConnection connection = 获取连接(连接字符串))
			{
				return 内部获取存储过程参数设置(connection, 存储过程名称, 返回值包含参数值);
			}
		}

		/// <summary>
		/// Retrieves the set of IDataParameters appropriate for the stored procedure
		/// </summary>
		/// <remarks>
		/// This method will query the database for this information, and then store it in a cache for future requests.
		/// </remarks>
		/// <param name="连接">A valid IDataConnection object</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <returns>An array of IDataParameters</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		public virtual IDataParameter[] 获取存储过程参数设置(IDbConnection 连接, string 存储过程名称)
		{
			return 获取存储过程参数设置(连接, 存储过程名称, false);
		}

		/// <summary>
		/// Retrieves the set of IDataParameters appropriate for the stored procedure
		/// </summary>
		/// <remarks>
		/// This method will query the database for this information, and then store it in a cache for future requests.
		/// </remarks>
		/// <param name="连接">A valid IDbConnection object</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="返回值包含参数值">A bool 值 indicating whether the return 值 parameter should be included in the results</param>
		/// <returns>An array of IDataParameters</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		public virtual IDataParameter[] 获取存储过程参数设置(IDbConnection 连接, string 存储过程名称, bool 返回值包含参数值)
		{
			if( 连接 == null ) throw new ArgumentNullException( "连接" );
			if( 连接 as ICloneable == null ) throw new ArgumentException( "cant discover parameters if the 连接 doesnt implement the ICloneable interface", "连接" );
			
			IDbConnection clonedConnection = (IDbConnection)((ICloneable)连接).Clone();
			return 内部获取存储过程参数设置(clonedConnection, 存储过程名称, 返回值包含参数值);
		}

		/// <summary>
		/// Retrieves the set of IDataParameters appropriate for the stored procedure
		/// </summary>
		/// <param name="连接">A valid IDbConnection object</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="返回值包含参数值">A bool 值 indicating whether the return 值 parameter should be included in the results</param>
		/// <returns>An array of IDataParameters</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		private IDataParameter[] 内部获取存储过程参数设置(IDbConnection 连接, string 存储过程名称, bool 返回值包含参数值)
		{
			if( 连接 == null ) throw new ArgumentNullException( "连接" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			// string hashKey = 连接.ConnectionString + ":" + 存储过程名称 + (返回值包含参数值 ? ":include ReturnValue Parameter":"");

			IDataParameter[] cachedParameters;
        	
			cachedParameters = 获取缓存参数设置(连接, 
						存储过程名称 + (返回值包含参数值 ? ":include ReturnValue Parameter":""));

			if (cachedParameters == null)
			{	
				IDataParameter[] spParameters = 识别存储过程参数设置(连接, 存储过程名称, 返回值包含参数值);
				缓存参数设置(连接,
								存储过程名称 + (返回值包含参数值 ? ":include ReturnValue Parameter":""), spParameters);

				cachedParameters = 数据访问器缓存参数.克隆参数(spParameters);
			}
        	
			return cachedParameters;
		}

		/// <summary>
		/// Retrieve a parameter array from the cache
		/// </summary>
		/// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <returns>An array of IDataParameters</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接字符串 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		public IDataParameter[] 获取缓存参数设置(string 连接字符串, string 命令内容)
		{
			using(IDbConnection connection = 获取连接(连接字符串))
			{
				return 内部获取缓存参数设置(connection, 命令内容);
			}
		}

		/// <summary>
		/// Retrieve a parameter array from the cache
		/// </summary>
		/// <param name="连接">A valid IDbConnection object</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <returns>An array of IDataParameters</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		public IDataParameter[] 获取缓存参数设置(IDbConnection 连接, string 命令内容)
		{
			return 内部获取缓存参数设置(连接, 命令内容);
		}

		/// <summary>
		/// Retrieve a parameter array from the cache
		/// </summary>
		/// <param name="连接">A valid IDbConnection object</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <returns>An array of IDataParameters</returns>
		private IDataParameter[] 内部获取缓存参数设置(IDbConnection 连接, string 命令内容)
		{
			bool mustCloseConnection = false;
			// this way we control the 连接, and therefore the 连接 string that gets saved as a hash 键
			if (连接.State != ConnectionState.Open) 
			{
				连接.Open();
				mustCloseConnection = true;
			}

			IDataParameter[] parameters = 数据访问器缓存参数.获取缓存参数设置(连接.ConnectionString, 命令内容);

			if (mustCloseConnection) 
			{
				连接.Close();
			}

			return parameters;
		}

		/// <summary>
		/// Add parameter array to the cache
		/// </summary>
		/// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <param name="命令参数集合">An array of IDataParameters to be cached</param>
		public void 缓存参数设置(string 连接字符串, string 命令内容, params IDataParameter[] 命令参数集合)
		{
			using(IDbConnection connection = 获取连接(连接字符串))
			{
				内部缓存参数设置(connection, 命令内容, 命令参数集合);
			}
		}

		/// <summary>
		/// Add parameter array to the cache
		/// </summary>
		/// <param name="连接">A valid IDbConnection</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <param name="命令参数集合">An array of IDataParameters to be cached</param>
		public void 缓存参数设置(IDbConnection 连接, string 命令内容, params IDataParameter[] 命令参数集合)
		{
			if (连接 is ICloneable)
			{
				using(IDbConnection clonedConnection = (IDbConnection)((ICloneable)连接).Clone())
				{
					内部缓存参数设置(clonedConnection, 命令内容, 命令参数集合);
				}
			}
			else
			{
				throw new InvalidCastException();
			}
		}

		/// <summary>
		/// Add parameter array to the cache
		/// </summary>
		/// <param name="连接">A valid IDbConnection</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <param name="命令参数集合">An array of IDataParameters to be cached</param>
		private void 内部缓存参数设置(IDbConnection 连接, string 命令内容, params IDataParameter[] 命令参数集合)
		{
			// this way we control the 连接, and therefore the 连接 string that gets saved as a hask 键
			连接.Open();
			数据访问器缓存参数.缓存参数设置(连接.ConnectionString, 命令内容, 命令参数集合);
			连接.Close();
		}
		
		/// <summary>
		/// Resolve at run time the appropriate set of IDataParameters for a stored procedure
		/// </summary>
		/// <param name="连接">A valid IDbConnection object</param>
		/// <param name="存储过程名称">The name of the stored procedure</param>
		/// <param name="返回值包含参数值">Whether or not to include their return 值 parameter</param>
		/// <returns>The parameter array discovered.</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 存储过程名称 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接 is null</exception>
		private IDataParameter[] 识别存储过程参数设置(IDbConnection 连接, string 存储过程名称, bool 返回值包含参数值)
		{
			if( 连接 == null ) throw new ArgumentNullException( "连接" );
			if( 存储过程名称 == null || 存储过程名称.Length == 0 ) throw new ArgumentNullException( "存储过程名称" );

			IDbCommand cmd = 连接.CreateCommand();
			cmd.CommandText = 存储过程名称;
			cmd.CommandType = CommandType.StoredProcedure;

			连接.Open();
			获得参数(cmd);
			连接.Close();

			if (!返回值包含参数值) 
			{
				// not all providers have return 值 parameters...don't just remove this parameter indiscriminately
				if (cmd.Parameters.Count > 0 && ((IDataParameter)cmd.Parameters[0]).Direction == ParameterDirection.ReturnValue)
				{
					cmd.Parameters.RemoveAt(0);
				}
			}
                
			IDataParameter[] discoveredParameters = new IDataParameter[cmd.Parameters.Count];

			cmd.Parameters.CopyTo(discoveredParameters, 0);

			// Init the parameters with a DBNull 值
			foreach (IDataParameter discoveredParameter in discoveredParameters)
			{
				discoveredParameter.Value = DBNull.Value;
			}
			return discoveredParameters;
		}
        
		#endregion Parameter Discovery Functions

    }
    #region 缓存参数
    /// <summary>
	/// 数据访问器缓存参数 provides functions to leverage a static cache of procedure parameters, and the
	/// ability to discover parameters for stored procedures at run-time.
	/// </summary>
	public sealed class 数据访问器缓存参数
	{
		private static Hashtable 缓存参数 = Hashtable.Synchronized(new Hashtable());

		/// <summary>
		/// Deep copy of cached IDataParameter array
		/// </summary>
		/// <param name="原始参数集合"></param>
		/// <returns></returns>
		internal static IDataParameter[] 克隆参数(IDataParameter[] 原始参数集合)
		{
			IDataParameter[] clonedParameters = new IDataParameter[原始参数集合.Length];

			for (int i = 0, j = 原始参数集合.Length; i < j; i++)
			{
				clonedParameters[i] = (IDataParameter)((ICloneable)原始参数集合[i]).Clone();
			}
			
			return clonedParameters;
		}

		#region 缓存函数

		/// <summary>
		/// Add parameter array to the cache
		/// </summary>
		/// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <param name="命令参数集合">An array of IDataParameters to be cached</param>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接字符串 is null</exception>
		internal static void 缓存参数设置(string 连接字符串, string 命令内容, params IDataParameter[] 命令参数集合)
		{
			if( 连接字符串 == null || 连接字符串.Length == 0 ) throw new ArgumentNullException( "连接字符串" );
			if( 命令内容 == null || 命令内容.Length == 0 ) throw new ArgumentNullException( "命令内容" );

			string hashKey = 连接字符串 + ":" + 命令内容;

			缓存参数[hashKey] = 命令参数集合;
		}

		/// <summary>
		/// Retrieve a parameter array from the cache
		/// </summary>
		/// <param name="连接字符串">A valid 连接 string for an IDbConnection</param>
		/// <param name="命令内容">The stored procedure name or SQL 命令</param>
		/// <returns>An array of IDataParameters</returns>
		/// <exception cref="System.ArgumentNullException">Thrown if 命令内容 is null</exception>
		/// <exception cref="System.ArgumentNullException">Thrown if 连接字符串 is null</exception>
		internal static IDataParameter[] 获取缓存参数设置(string 连接字符串, string 命令内容)
		{
			if( 连接字符串 == null || 连接字符串.Length == 0 ) throw new ArgumentNullException( "连接字符串" );
			if( 命令内容 == null || 命令内容.Length == 0 ) throw new ArgumentNullException( "命令内容" );

			string hashKey = 连接字符串 + ":" + 命令内容;

			IDataParameter[] cachedParameters = 缓存参数[hashKey] as IDataParameter[];
			if (cachedParameters == null)
			{			
				return null;
			}
			else
			{
				return 克隆参数(cachedParameters);
			}
		}

		#endregion caching functions
	}
	#endregion
}
